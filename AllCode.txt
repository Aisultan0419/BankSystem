using Domain.Enums;
using Domain.Models;

namespace Application.DTO.AppUserDTO
{
    public class AppUserCreateDTO
    {
        public required string Email { get; set; }
        public required string PasswordHash { get; set; }
        public required string IIN { get; set; }
        public string PinCode { get; set; } = null!;    
    }
}

using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using Domain.Models;

namespace Application.DTO.AuthDTO
{
    public class LoginStatusDTO
    {
        public string VerificationStatus { get; set; } = "NotStarted";
        public string Message { get; set; } = "";
        public string Token { get; set; } = "";
        public string RefreshToken { get; set; } = "";
        public int ExpiresIn { get; set; }
        public Guid UserId { get; set; }
        public string? DeviceInfo { get; set; }
    }
}


namespace Application.DTO.AuthDTO
{
    public class LoginViaPasswordDTO
    {
        public required string Email { get; set; }
        public required string Password { get; set; }
    }
}


namespace Application.DTO.AuthDTO
{
    public class LoginViaPinDTO
    {
        public required string Email { get; set; }
        public required string PinCode { get; set; }
    }
}

using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using Domain.Enums;
using Domain.Models;

namespace Application.DTO.CardDTO
{
    public class CardRequisitesDTO
    {
        public string full_name { get; init; } = null!;
        public string Pan { get; init; } = null!;
        public string? ExpiryDate { get; init; }
    }
}

using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using Domain.Enums;

namespace Application.DTO.CardDTO
{
    public class GetCardDTO
    {
        public string? PanMasked { get; init; }
        public string? Status { get; init; }
        public decimal Balance { get; init; }
        public string? Currency { get; } = "KZT";

    }
}

using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace Application.DTO.CardDTO
{
    public class LastNumbersDTO
    {
        public required string LastNumbers { get; set; }
    }
}

using Domain.Enums;
using Domain.Models;

namespace Application.DTO.ClientDTO
{
    public class ClientCreateDTO
    {
        public required string IIN { get; set; } 
        public required string FullName { get; set; }
        public string? PhoneNumber { get; set; }
    }
}


namespace Application.DTO.ClientDTO
{
    public class IINDTO
    {
        public required string IIN { get; set; }
    }
}

namespace Application.DTO.ClientDTO
{
    public class RegistrationStatusDTO
    {
        public string KycStatus { get; set; } = "NotStarted";
        public string VerificationStatus { get; set; } = "NotStarted";
        public string Message { get; set; } = "";
    }
}


namespace Application.DTO.TransactionDTO
{
    public class DepositQueryDTO
    {
        public decimal Amount { get; set; }
        public string LastNumbers { get; set; } = null!;
    }
}

using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace Application.DTO.TransactionDTO
{
    public class DepositResponseDTO
    {
        public decimal? depositedAmount { get; set; }
        public string? message { get; set; }
        public decimal? newBalance { get; set; }
    }
}


namespace Application.DTO.TransactionDTO
{
    public class TransferQueryDTO
    {
        public required string Iban { get; set; }
        public required decimal Amount { get; set; }
        public required string LastNumbers { get; set; }
    }
}

using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace Application.DTO.TransactionDTO
{
    public class TransferResponseDTO
    {
        public string? Full_name { get; set; }
        public decimal? transferredAmount { get; set; }
        public decimal? remainingBalance { get; set; }
        public string? message { get; set; }
    }
}

using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using Domain.Models;

namespace Application.Interfaces.Auth
{
    public interface IJwtProvider
    {
        string GenerateToken(AppUser appUser);
    }
}

namespace Application.Interfaces.Auth
{
    public interface IHasher
    {
        string Generate(string input);
        bool Verify(string input, string hashedInput);
    }
}

using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using Domain.Models;

namespace Application.Interfaces.Auth
{
    public interface IRefreshTokenProvider
    {
        Task<RefreshToken> GenerateRefreshToken(Guid userId);
        string RefreshTokenHasher(string Token);
    }
}

using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using Application.DTO.CardDTO;
using Domain.Models;

namespace Application.Interfaces.Repositories
{
    public interface IAccountRepository
    {
        Task AddEncyptedPan(Pan pan);
        Task AddCard(Card card);
        Task AddAccount(Account account);
        Task<IEnumerable<GetCardDTO>> GetAllCards(Guid clientId);
        Task<Card> GetRequisitesDTOAsync(Guid clientId, string last_numbers);
        Task<Account> GetAccountById(Guid accountId);
        Task<Account> GetAccountByIban(string iban);
    }
}

using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using Domain.Models;

namespace Application.Interfaces.Repositories
{
    public interface IAppUserRepository
    {
        Task<bool> ExistsByEmailAsync(string email);
        Task<AppUser?> GetAppUserByEmail(string email);
        Task<AppUser> GetAppUserAsync(Guid Id);
        Task SaveDataAppUserAsync(AppUser appUser);
    }
}

using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using Domain.Models;

namespace Application.Interfaces.Repositories
{
    public interface IAuthRepository
    {
        Task SaveRefreshToken(RefreshToken refreshToken);
        Task<RefreshToken?> FindRefreshToken(string refreshToken);
    }
}

using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using Domain.Models;

namespace Application.Interfaces.Repositories
{
    public interface IClientRepository
    {
        Task<bool> ExistsByIINAsync(string iin);
        Task SaveDataClientAsync(Client client);
        Task<int> DeleteAsync(string IIN);
        Task<Client?> FindByIINAsync(string IIN);
    }
}

using Microsoft.EntityFrameworkCore.Storage;
using Domain.Models;
namespace Application.Interfaces.Repositories
{
    public interface ITransactionRepository
    {
        Task<IDbContextTransaction> BeginTransactionAsync();
        Task AddTransaction(Transaction transaction);
    }
}

using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using Domain.Models;

namespace Application.Interfaces.Repositories
{
    public interface IUserRepository
    {
        Task SaveChangesAsync();
        Task<string?> GetOrderNumber();
    }
}

using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using Domain.Models;

namespace Application.Interfaces.Services
{
    public interface IAccountService
    {
        Task<Account> CreateAccount(Client client);
    }
}

using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using Application.DTO.AppUserDTO;
using Application.DTO.ClientDTO;

namespace Application.Interfaces.Services
{
    public interface IAppUserService
    {
        Task<RegistrationStatusDTO> RegisterAppUser(AppUserCreateDTO AppUserDTO);
    }
}

using Application.DTO.AuthDTO;

namespace Application.Interfaces.Services
{
    public interface IAuthService
    {
        Task<LoginStatusDTO> LoginPin(string appUserId, string pinCode);
        Task<LoginStatusDTO> RefreshToken();
        Task<LoginStatusDTO> LoginPassword(string email, string password);
    }
}

using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using Domain.Models;

namespace Application.Interfaces.Services
{
    public interface ICardService
    {
        Card CreateCard(Client client);
    }
}

using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using Application.DTO.ClientDTO;

namespace Application.Interfaces.Services
{
    public interface IClientService
    {
        Task<RegistrationStatusDTO> Register(ClientCreateDTO ClientDTO);
        Task<bool> DeleteClient(string IIN);
    }
}

using Application.DTO.TransactionDTO;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace Application.Interfaces.Services
{
    public interface IDepositService
    {
        Task<DepositResponseDTO> DepositAsync(decimal amount, string appUserId, string lastNumbers);
    }
}

using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using Application.DTO.CardDTO;

namespace Application.Interfaces.Services
{
    public interface IGetCardService
    {
        Task<IEnumerable<GetCardDTO>> GetAllCards(string appUserId);
    }
}

using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using Application.DTO.CardDTO;

namespace Application.Interfaces.Services
{
    public interface IGetRequisitesOfCardService
    {
        Task<CardRequisitesDTO> GetRequisitesOfCard(string appUserId, string last_numbers);
    }
}

using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using Domain.Enums;

namespace Application.Interfaces.Services
{
    public interface IIBanService
    {
        Task<string> GetIban(AccountType accountType, Guid Id);
        int Mod97(string input);
        string Digitalization(string letters);
    }
}

using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using Domain.Models;

namespace Application.Interfaces.Services
{
    public interface IPanService
    {
        string CreatePan(Client client);
        string ControlNumber(string BIN, string card_number);
    }
}

using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using Application.Interfaces.Auth;
using Domain.Models;

namespace Application.Interfaces.Services
{
    public interface ITokenService
    {
        string GenerateJwt(AppUser appUser);
        Task<RefreshToken> CreateRefreshTokenAsync(Guid userId);
        string HashRefreshToken(string token);
    }
}

using Application.DTO.TransactionDTO;
namespace Application.Interfaces.Services
{
    public interface ITransferService
    {
        Task<TransferResponseDTO> TransferAsync(string appUserId, string iban, decimal amount, string lastNumbers);
    }
}

using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace Application.Interfaces
{
    public interface IPanEncryptor
    {
        (byte[] CipherText, byte[] Nonce, byte[] Tag) Encrypt(string pan);
        string Decrypt(byte[] CipherText, byte[] Nonce, byte[] Tag);
    }
}

using System;
using System.Security.Cryptography;
using Application.DTO;
using AutoMapper;

namespace Application.Mappings
{
   public class MappingProfile : Profile
    {
       
    }
}

// <autogenerated />
using System;
using System.Reflection;
[assembly: global::System.Runtime.Versioning.TargetFrameworkAttribute(".NETCoreApp,Version=v9.0", FrameworkDisplayName = ".NET 9.0")]

//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Runtime Version:4.0.30319.42000
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

using System;
using System.Reflection;

[assembly: System.Reflection.AssemblyCompanyAttribute("Application")]
[assembly: System.Reflection.AssemblyConfigurationAttribute("Debug")]
[assembly: System.Reflection.AssemblyFileVersionAttribute("1.0.0.0")]
[assembly: System.Reflection.AssemblyInformationalVersionAttribute("1.0.0+89d32106120063aadf12636df3d6a97522ccdea6")]
[assembly: System.Reflection.AssemblyProductAttribute("Application")]
[assembly: System.Reflection.AssemblyTitleAttribute("Application")]
[assembly: System.Reflection.AssemblyVersionAttribute("1.0.0.0")]

// Generated by the MSBuild WriteCodeFragment class.


// <auto-generated/>
global using global::System;
global using global::System.Collections.Generic;
global using global::System.IO;
global using global::System.Linq;
global using global::System.Net.Http;
global using global::System.Threading;
global using global::System.Threading.Tasks;

// <autogenerated />
using System;
using System.Reflection;
[assembly: global::System.Runtime.Versioning.TargetFrameworkAttribute(".NETCoreApp,Version=v9.0", FrameworkDisplayName = ".NET 9.0")]

//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Runtime Version:4.0.30319.42000
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

using System;
using System.Reflection;

[assembly: System.Reflection.AssemblyCompanyAttribute("Application")]
[assembly: System.Reflection.AssemblyConfigurationAttribute("Release")]
[assembly: System.Reflection.AssemblyFileVersionAttribute("1.0.0.0")]
[assembly: System.Reflection.AssemblyInformationalVersionAttribute("1.0.0+ba47c6a8ad9d8ab08ed9550af9048b5c55076af1")]
[assembly: System.Reflection.AssemblyProductAttribute("Application")]
[assembly: System.Reflection.AssemblyTitleAttribute("Application")]
[assembly: System.Reflection.AssemblyVersionAttribute("1.0.0.0")]

// Generated by the MSBuild WriteCodeFragment class.


// <auto-generated/>
global using global::System;
global using global::System.Collections.Generic;
global using global::System.IO;
global using global::System.Linq;
global using global::System.Net.Http;
global using global::System.Threading;
global using global::System.Threading.Tasks;

using Application.Interfaces.Repositories;
using Domain.Models;
using Domain.Enums;
using Application.Interfaces.Services;
namespace Application.Services.AccountServices
{
    public class AccountService : IAccountService
    {
        private readonly IUserRepository _userRepository;
        private readonly IIBanService _ibanService;
        private readonly IAccountRepository _accountRepository;
        private readonly ICardService _cardService;
        public AccountService(IUserRepository userRepository
            ,IIBanService ibanService
            ,IAccountRepository accountRepository
            ,ICardService cardService)
        {
            _userRepository = userRepository;
            _ibanService = ibanService;
            _accountRepository = accountRepository;
            _cardService = cardService;
        }

        public async Task<Account> CreateAccount(Client client)
        {
            var iban = await _ibanService.GetIban(AccountType.Current, client.Id);
            var account = new Account
            {
                Id = Guid.NewGuid(),
                Client = client,
                ClientId = client.Id,
                Iban = iban,
            };
            var card = _cardService.CreateCard(client);
            card.Account = account;
            card.AccountId = account.Id;
            account.Cards.Add(card);
            return account;
        }
    }
}

using Application.Interfaces.Services;
using System.Text;
using Application.Interfaces.Repositories;
using Domain.Enums;
namespace Application.Services.AccountServices
{
    public class IbanService : IIBanService
    {
        private readonly IUserRepository _userRepository;
        public IbanService(IUserRepository userRepository)
        {
            _userRepository = userRepository;
        }            
        public async Task<string> GetIban(AccountType accountType, Guid Id)
        {
            string unique_id = (Math.Abs(Id.GetHashCode()) % 10000).ToString("D4");
            string order_number = await _userRepository.GetOrderNumber() 
                ?? throw new InvalidOperationException("Failed to generate account order number");
            string account_type = ((int)accountType).ToString("D3");
            string unique_number = string.Concat(account_type, unique_id, order_number);

            const string country_code = "KZ";
            const string bank_code = "AISS";

            string letters = country_code + bank_code;

            string digitalized_code = Digitalization(letters);

            string checkDigits = (98 - Mod97(string.Concat(unique_number, digitalized_code))).ToString("D2");
            
            string iban = string.Concat(country_code, checkDigits, bank_code, unique_number);

            return iban;
        }
        public int Mod97(string input)
        {
            string remainder = input;
            long block = 0;
            while (remainder.Length > 0)
            {
                int take = Math.Min(9, remainder.Length);
                block = long.Parse(block.ToString() + remainder.Substring(0, take));
                remainder = remainder.Substring(take);
                block %= 97;
            }
            return (int)block;
        }
        public string Digitalization(string letters)
        {
            StringBuilder stringBuilder = new StringBuilder();

            foreach (char c in letters)
            {
                if (char.IsLetter(c))
                {
                    int value = char.ToUpper(c) - 'A' + 10;
                    stringBuilder.Append(value);
                }
                else
                {
                    stringBuilder.Append(c);
                }
            }
            return stringBuilder.ToString();
        }
    }
}

using Application.DTO.AppUserDTO;
using Application.DTO.ClientDTO;
using Application.Interfaces.Auth;
using Application.Interfaces.Repositories;
using Application.Interfaces.Services;
using Domain.Enums;
using Domain.Models;
namespace Application.Services.AppUserServices
{
    public class AppUserService : IAppUserService
    {
       
        private readonly IUserRepository _userRepository;
        private readonly IAppUserRepository _appUserRepository;
        private readonly IHasher _Hasher;
        private readonly IClientRepository _clientRepository;
        public AppUserService(IUserRepository userRepository
            ,IHasher Hasher
            ,IAppUserRepository appUserRepository
            ,IClientRepository clientRepository)
        {
            _userRepository = userRepository;
            _Hasher = Hasher;
            _appUserRepository = appUserRepository;
            _clientRepository = clientRepository;
        }
        public async Task<RegistrationStatusDTO> RegisterAppUser(AppUserCreateDTO AppUserDTO)
        {
            var client = await _clientRepository.FindByIINAsync(AppUserDTO.IIN);
            if (client == null)
            {
                return new RegistrationStatusDTO
                {
                    KycStatus = KycStatus.NotStarted.ToString(),
                    VerificationStatus = VerificationStatus.Rejected.ToString(),
                    Message = "There is no such client to connect"
                };
            }
            var appUser = new AppUser
            {
                Id = Guid.NewGuid(),
                Email = AppUserDTO.Email,
                PasswordHash = _Hasher.Generate(AppUserDTO.PasswordHash!),
                HashedPinCode = _Hasher.Generate(AppUserDTO.PinCode!),
                VerificationStatus = VerificationStatus.Pending,
                Client = client,
                IsActive = false
            };
            var appuserexists = await _appUserRepository.ExistsByEmailAsync(appUser.Email);
            if (appuserexists)
            {
                return new RegistrationStatusDTO
                {
                    KycStatus = KycStatus.NotStarted.ToString(),
                    VerificationStatus = VerificationStatus.Rejected.ToString(),
                    Message = "There is already such app user in the system"
                };
            }
            appUser.VerificationStatus = VerificationStatus.Verified;
            appUser.IsActive = true;

            await _appUserRepository.SaveDataAppUserAsync(appUser);

            await _userRepository.SaveChangesAsync();
            
            return new RegistrationStatusDTO
            {
                KycStatus = KycStatus.Verified.ToString(),
                VerificationStatus = VerificationStatus.Verified.ToString(),
                Message = "The user successfully has been saved"
            };
        }
    }
}

using Application.Interfaces.Auth;
using Application.Interfaces.Repositories;
using Domain.Configuration;
using Domain.Enums;
using Domain.Models;
using Microsoft.AspNetCore.Http;
using Microsoft.Extensions.Options;
using Application.Interfaces.Services;
using Application.DTO.AuthDTO;
namespace Application.Services.AuthServices
{
    public class AuthService : IAuthService
    {
        private readonly IUserRepository _userRepository;
        private readonly IHasher _Hasher;
        private readonly ITokenService _tokenService;
        private readonly IOptions<JwtOptions> _options;
        private readonly IHttpContextAccessor _httpContextAccessor;
        private readonly IAppUserRepository _appUserRepository;
        private readonly IAuthRepository _authRepository;
        public DateTime kazTime = TimeZoneInfo.ConvertTimeFromUtc(DateTime.UtcNow, TimeZoneInfo.FindSystemTimeZoneById("Asia/Almaty"));
        public DateTime utcNow = DateTime.UtcNow;
        public AuthService(IUserRepository userRepository
            , IHasher Hasher
            , IOptions<JwtOptions> options
            , IHttpContextAccessor httpContextAccessor
            , ITokenService tokenService
            , IAppUserRepository appUserRepository
            , IAuthRepository authRepository)
        {
            _httpContextAccessor = httpContextAccessor;
            _userRepository = userRepository;
            _Hasher = Hasher;
            _options = options;
            _tokenService = tokenService;
            _appUserRepository = appUserRepository;
            _authRepository = authRepository;
        }
        public async Task<LoginStatusDTO> LoginPin(string email, string pinCode)
        {
            var appUser = await _appUserRepository.GetAppUserByEmail(email);
            if (appUser == null)
            {
                return new LoginStatusDTO
                {
                    VerificationStatus = VerificationStatus.Rejected.ToString(),
                    Message = "There is no such app user, please register"
                };
            }
            if (appUser.BlockedUntil != null && appUser.BlockedUntil > utcNow)
            {
                return new LoginStatusDTO
                {
                    VerificationStatus = VerificationStatus.Rejected.ToString(),
                    Message = $"User is blocked until {TimeZoneInfo.ConvertTimeFromUtc(appUser.BlockedUntil.Value,
                                TimeZoneInfo.FindSystemTimeZoneById("Asia/Almaty"))}"
                };
            }
            if (appUser.CountOfLoginAttempts > 3)
            {
                var utcNow = DateTime.UtcNow;
                appUser.BlockedUntil = utcNow.AddHours(3);
                await _userRepository.SaveChangesAsync();
            }
            var result_verification = _Hasher.Verify(pinCode, appUser.HashedPinCode!);
            if (result_verification == false)
            {
                appUser.CountOfLoginAttempts++;
                await _userRepository.SaveChangesAsync();
                return new LoginStatusDTO
                {
                    VerificationStatus = VerificationStatus.Rejected.ToString(),
                    Message = "Incorrect pin code"
                };
            }
            appUser.BlockedUntil = null;
            appUser.CountOfLoginAttempts = 0;
            appUser.BlockedUntilPassword = null;
            appUser.CountOfLoginViaPasswordAttempts = 0;
            var token = _tokenService.GenerateJwt(appUser);
            var refreshToken = await _tokenService.CreateRefreshTokenAsync(appUser.Id);
            var hashed_one = new RefreshToken
            {
                Id = refreshToken.Id,
                Token = _tokenService.HashRefreshToken(refreshToken.Token),
                Expires = refreshToken.Expires,
                AppUser = appUser,
                UserId = appUser.Id
            };
            await _authRepository.SaveRefreshToken(hashed_one);
            await _userRepository.SaveChangesAsync();
            return new LoginStatusDTO
            {
                VerificationStatus = VerificationStatus.Verified.ToString(),
                Message = "User is logined successfully",
                Token = token,
                RefreshToken = refreshToken.Token,
                ExpiresIn = _options.Value.ExpireMinutes,
                UserId = appUser.Id,
                DeviceInfo = refreshToken.DeviceInfo
            };
        }
        public async Task<LoginStatusDTO> LoginPassword(string email, string password)
        {
            var appUser = await _appUserRepository.GetAppUserByEmail(email);
            if (appUser == null)
            {
                return new LoginStatusDTO
                {
                    VerificationStatus = VerificationStatus.Rejected.ToString(),
                    Message = "There is no such app user, please register"
                };
            }
            if (appUser.BlockedUntilPassword != null && appUser.BlockedUntilPassword > utcNow)
            {
                return new LoginStatusDTO
                {
                    VerificationStatus = VerificationStatus.Rejected.ToString(),
                    Message = $"User is blocked until {TimeZoneInfo.ConvertTimeFromUtc(appUser.BlockedUntilPassword.Value,
                                TimeZoneInfo.FindSystemTimeZoneById("Asia/Almaty"))}"
                };
            }
            if (appUser.CountOfLoginViaPasswordAttempts > 3)
            {
                var utcNow = DateTime.UtcNow;
                appUser.BlockedUntilPassword = utcNow.AddHours(3);
                await _userRepository.SaveChangesAsync();
            }
            var result_verification = _Hasher.Verify(password, appUser.PasswordHash!);
            if (result_verification == false)
            {
                appUser.CountOfLoginViaPasswordAttempts++;
                await _userRepository.SaveChangesAsync();
                return new LoginStatusDTO
                {
                    VerificationStatus = VerificationStatus.Rejected.ToString(),
                    Message = "Incorrect password"
                };
            }
            appUser.BlockedUntil = null;
            appUser.CountOfLoginAttempts = 0;
            appUser.BlockedUntilPassword = null;
            appUser.CountOfLoginViaPasswordAttempts = 0;
            var token = _tokenService.GenerateJwt(appUser);
            var refreshToken = await _tokenService.CreateRefreshTokenAsync(appUser.Id);
            var hashed_one = new RefreshToken
            {
                Id = refreshToken.Id,
                Token = _tokenService.HashRefreshToken(refreshToken.Token),
                Expires = refreshToken.Expires,
                AppUser = appUser,
                UserId = appUser.Id
            };
            await _authRepository.SaveRefreshToken(hashed_one);
            await _userRepository.SaveChangesAsync();
            return new LoginStatusDTO
            {
                VerificationStatus = VerificationStatus.Verified.ToString(),
                Message = "User is logined successfully",
                Token = token,
                RefreshToken = refreshToken.Token,
                ExpiresIn = _options.Value.ExpireMinutes,
                UserId = appUser.Id,
                DeviceInfo = refreshToken.DeviceInfo
            };
        }
        public async Task<LoginStatusDTO> RefreshToken()
        {
            if (!_httpContextAccessor.HttpContext.Request.Cookies.TryGetValue("refreshToken", out var refreshToken))
            {
                return new LoginStatusDTO
                {
                    VerificationStatus = VerificationStatus.Rejected.ToString(),
                    Message = "No refresh token"
                };
            }
            var hashedRefreshToken = _tokenService.HashRefreshToken(refreshToken);
            var storedRefreshToken = await _authRepository.FindRefreshToken(hashedRefreshToken);
            if (storedRefreshToken == null)
            {
                return new LoginStatusDTO
                {
                    VerificationStatus = VerificationStatus.Rejected.ToString(),
                    Message = "Invalid refresh token"
                };
            }
            var appUser = storedRefreshToken.AppUser;
            if (storedRefreshToken.Expires < utcNow)
            {
                storedRefreshToken.RevokedAt = utcNow;
                return new LoginStatusDTO
                {
                    VerificationStatus = VerificationStatus.Rejected.ToString(),
                    Message = "Expired refresh token"
                };
            }
            var token = _tokenService.GenerateJwt(storedRefreshToken.AppUser);
            return new LoginStatusDTO
            {
                VerificationStatus = VerificationStatus.Verified.ToString(),
                Message = "User is relogined successfully",
                Token = token,
                RefreshToken = storedRefreshToken.Token,
                ExpiresIn = _options.Value.ExpireMinutes,
                UserId = appUser!.Id,
                DeviceInfo = storedRefreshToken.DeviceInfo
            };
        }
    }
}

using Application.Interfaces.Auth;
using Application.Interfaces.Repositories;
using Application.Interfaces.Services;
using Domain.Configuration;
using Domain.Models;
using Microsoft.Extensions.Options;

namespace Application.Services.AuthServices
{
    public class TokenService : ITokenService
    {
        private readonly IUserRepository _userRepository;
        private readonly IJwtProvider _jwtprovider;
        private readonly IRefreshTokenProvider _refreshTokenProvider;
        private readonly IOptions<JwtOptions> _options;
        public TokenService(IUserRepository userRepository
            , IJwtProvider jwtprovider
            , IRefreshTokenProvider refreshTokenProvider
            , IOptions<JwtOptions> options)
        {
            _userRepository = userRepository;
            _jwtprovider = jwtprovider;
            _refreshTokenProvider = refreshTokenProvider;
            _options = options;
        }
        public string GenerateJwt(AppUser appUser) => _jwtprovider.GenerateToken(appUser);
        public Task<RefreshToken> CreateRefreshTokenAsync(Guid userId)
            => _refreshTokenProvider.GenerateRefreshToken(userId);
        public string HashRefreshToken(string token) => _refreshTokenProvider.RefreshTokenHasher(token);
    }
}

using Domain.Models;
using Domain.Enums;
using Application.Interfaces.Services;
using Application.Interfaces;
using Application.Interfaces.Repositories;
namespace Application.Services.CardServices
{
    public class CardService : ICardService
    {
        private readonly IPanService _panService;
        private readonly IPanEncryptor _panEncryptor;
        private readonly IAccountRepository _accountRepository;
        private readonly IUserRepository _userRepository;
        public CardService(IPanService panService
            ,IPanEncryptor panEncryptor
            ,IAccountRepository accountRepository
            ,IUserRepository userRepository)
        {
            _panService = panService;
            _panEncryptor = panEncryptor;
            _accountRepository = accountRepository;
            _userRepository = userRepository;
        }
        public Card CreateCard(Client client)
        {
            var pan = _panService.CreatePan(client);
            var encrypted = _panEncryptor.Encrypt(pan);
            var encypted_pan = new Pan
            {
                Id = Guid.NewGuid(),
                CipherText = encrypted.CipherText,
                Nonce = encrypted.Nonce,
                Tag = encrypted.Tag
            };
            
            var card = new Card
            {
                Id = Guid.NewGuid(),
                ExpiryDate = (DateTime.UtcNow.AddYears(3)).ToString("MM/yy"),
                Status = CardStatus.Active,
                PanMasked = new string('*', 12) + pan[^4..],
                Pan = encypted_pan
            };
            encypted_pan.Card = card;
            return card;
        }

    }
}

using Application.DTO.CardDTO;
using Application.Interfaces.Repositories;
using Application.Interfaces.Services;
namespace Application.Services.CardServices
{
    public class GetCardService : IGetCardService
    {
        private readonly IAppUserRepository _appUserRepository;
        private readonly IAccountRepository _accountRepository;
        public GetCardService(IAppUserRepository appUserRepository, IAccountRepository accountRepository)
        {
            _appUserRepository = appUserRepository;
            _accountRepository = accountRepository;
        }
        public async Task<IEnumerable<GetCardDTO>> GetAllCards(string appUserId)
        {
            var appUser = await _appUserRepository.GetAppUserAsync(Guid.Parse(appUserId)) ?? throw new Exception();

            var client = appUser.Client;

            var result = await _accountRepository.GetAllCards(client.Id) ?? throw new Exception();

            return result;
        }
    }
}

using System;
using System.Collections.Generic;
using Application.Interfaces;
using Application.Interfaces.Repositories;
using Application.Interfaces.Services;
using Application.DTO.CardDTO;
using System.Security.Cryptography;

namespace Application.Services.CardServices
{
    public class GetRequisitesOfCardService : IGetRequisitesOfCardService
    {
        private readonly IAppUserRepository _appUserRepository;
        private readonly IAccountRepository _accountRepository;
        private readonly IPanEncryptor _panEncryptor;
        public GetRequisitesOfCardService(IAppUserRepository appUserRepository
            ,IAccountRepository accountRepository
            ,IPanEncryptor panEncryptor)
        {
            _appUserRepository = appUserRepository;
            _accountRepository = accountRepository;
            _panEncryptor = panEncryptor;
        }
        public async Task<CardRequisitesDTO> GetRequisitesOfCard(string appUserId, string last_numbers)
        {
            Guid.TryParse(appUserId, out var appUserIdGuid);

            var appUser = await _appUserRepository.GetAppUserAsync(appUserIdGuid) ?? throw new Exception("AppUser was not found");

            var clientId = appUser.Client.Id;

            var card = await _accountRepository.GetRequisitesDTOAsync(clientId, last_numbers);
            string pan_string;
            try
            {
                pan_string = _panEncryptor.Decrypt(card.Pan.CipherText, card.Pan.Nonce, card.Pan.Tag);
            }
            catch (CryptographicException)
            {
                return new CardRequisitesDTO
                {
                    full_name = appUser.Client.FullName!,
                    Pan = "Invalid Pan",
                    ExpiryDate = card.ExpiryDate
                };
            }
            var result = new CardRequisitesDTO { 
                full_name = appUser.Client.FullName!,
                Pan = pan_string,
                ExpiryDate = card.ExpiryDate
            };
            return result;

        }
    }
}

using Application.DTO.ClientDTO;
using Application.Interfaces.Repositories;
using Application.Interfaces.Services;
using Domain.Enums;
using Domain.Models;

namespace Application.Services.ClientServices
{
    public class ClientService : IClientService
    {
        private readonly IUserRepository _userRepository;
        private readonly IClientRepository _clientRepository;
        private readonly IAccountService _accountService;
        private readonly IAccountRepository _accountRepository;
        public ClientService(IUserRepository userRepository
            ,IClientRepository clientRepository
            ,IAccountService accountService
            ,IAccountRepository accountRepository)
        {
            _userRepository = userRepository;
            _clientRepository = clientRepository;
            _accountService = accountService;
            _accountRepository = accountRepository;
        }
        public async Task<RegistrationStatusDTO> Register(ClientCreateDTO ClientDTO)
        {
            var client = new Client
            {
                Id = Guid.NewGuid(),
                IIN = ClientDTO.IIN,
                KycStatus = KycStatus.Pending,
                FullName = ClientDTO.FullName,
                IsDeleted = false,
                PhoneNumber = ClientDTO.PhoneNumber
            };
            
            var exists = await _clientRepository.ExistsByIINAsync(client.IIN!);

            if (exists) return new RegistrationStatusDTO
            {
                KycStatus = KycStatus.Rejected.ToString(),
                Message = "Client data is already in the system!"
            };
            client.KycStatus = KycStatus.Verified;
            await _clientRepository.SaveDataClientAsync(client);

            var account = await _accountService.CreateAccount(client);
            await _accountRepository.AddAccount(account);
            await _userRepository.SaveChangesAsync();
            return new RegistrationStatusDTO()
            {
                KycStatus = KycStatus.Verified.ToString(),
                Message = "Client successfully has been saved"
            };
        }
        public async Task<bool> DeleteClient(string IIN)
        {
            var affected = await _clientRepository.DeleteAsync(IIN);
            return affected > 0;
        }
    }
}

using Application.DTO.TransactionDTO;
using Application.Interfaces.Repositories;
using Application.Interfaces.Services;
using Domain.Models;
using System.Reflection.Metadata.Ecma335;

namespace Application.Services.TransactionServices
{
    public class DepositService : IDepositService
    {
        private readonly IAppUserRepository _appUserRepository;
        private readonly IUserRepository _userRepository;
        private readonly IAccountRepository _accountRepository;
        private readonly ITransactionRepository _transactionRepository;
        private static readonly TimeZoneInfo tz = TimeZoneInfo.FindSystemTimeZoneById("Asia/Almaty");
        private DateTime KazNow => TimeZoneInfo.ConvertTimeFromUtc(DateTime.UtcNow, tz);
        private DateOnly KazToday => DateOnly.FromDateTime(KazNow);
        public DepositService(IAppUserRepository appUserRepository
            ,IUserRepository userRepository
            ,IAccountRepository accountRepository
            ,ITransactionRepository transactionRepository)
        {
            _appUserRepository = appUserRepository;
            _userRepository = userRepository;
            _accountRepository = accountRepository;
            _transactionRepository = transactionRepository;
        }
        private const decimal daily_limit = 2000000m;
        public async Task<DepositResponseDTO> DepositAsync(decimal amount, string appUserId, string lastNumbers)
        {
            Guid.TryParse(appUserId, out var appUserGuid);
            var appUser = await _appUserRepository.GetAppUserAsync(appUserGuid);
            if (appUser == null)
            {
                return new DepositResponseDTO
                {
                    message = "AppUser was not found"
                };
            }
            if (isValidAmount(amount) == false) return new DepositResponseDTO { message = "Invalid amount" };
            var clientId = appUser.Client.Id;
            var card = await _accountRepository.GetRequisitesDTOAsync(clientId, lastNumbers);
            if (card == null)
            {
                return new DepositResponseDTO
                {
                    message = "Card was not found"
                };
            }
            var account = await _accountRepository.GetAccountById(card.AccountId);
            var resultOfCheck = checkLimit(account, amount);
            if (resultOfCheck.Item1 == false)
            {
                return new DepositResponseDTO
                {
                    message = $"You can deposit only {resultOfCheck.Item2}"
                };
            }
            using (var tx = await _transactionRepository.BeginTransactionAsync())
            {
                try
                {
                    account.Deposit(amount);
                    account.DepositedLastDay += amount;
                    account.LastDepositDateKz = KazToday;   
                    var transaction = new Transaction
                    {
                        Id = Guid.NewGuid(),
                        From = "External",
                        To = account.Iban.ToString(),
                        ClientId = appUser.Client.Id,
                        Amount = amount,
                        CreatedAt = DateTime.UtcNow,
                        Type = "Deposit"
                    };
                    await _transactionRepository.AddTransaction(transaction);
                    await _userRepository.SaveChangesAsync();   

                    await tx.CommitAsync();
                }
                catch
                {
                    await tx.RollbackAsync();
                    throw;
                }
            }


            return new DepositResponseDTO
            {
                message = "Balance is succesfully replenished",
                depositedAmount = amount,
                newBalance = account.Balance
            };
            
        }
        private bool isValidAmount(decimal amount) => amount > 0 && amount <= daily_limit;
        private (bool, decimal?) checkLimit(Account account, decimal amount)
        {
            if (account.LastDepositDateKz != KazToday)
            {
                account.DepositedLastDay = 0m;
                account.LastDepositDateKz = KazToday;
            }
            if (account.DepositedLastDay + amount > daily_limit)
            {
                var canDeposit = daily_limit - account.DepositedLastDay;
                return (false, canDeposit);
            }
            return (true, null);
        }
    }
}

using Application.DTO.TransactionDTO;
using Application.Interfaces.Repositories;
using Application.Interfaces.Services;
using Domain.Models;
using System.Runtime.CompilerServices;
namespace Application.Services.TransactionServices
{
    public class TransferService : ITransferService
    {
        private readonly IAppUserRepository _appUserRepository;
        private readonly IAccountRepository _accountRepository;
        private readonly IUserRepository _userRepository;
        private readonly ITransactionRepository _transactionRepository;
        private const decimal daily_limit = 2000000m;
        private static readonly TimeZoneInfo tz = TimeZoneInfo.FindSystemTimeZoneById("Asia/Almaty");
        private DateTime KazNow => TimeZoneInfo.ConvertTimeFromUtc(DateTime.UtcNow, tz);
        private DateOnly KazToday => DateOnly.FromDateTime(KazNow);
        public TransferService(IAppUserRepository appUserRepository
            ,IAccountRepository accountRepository
            ,IUserRepository userRepository
            ,ITransactionRepository transactionRepository)
        {
            _appUserRepository = appUserRepository;
            _accountRepository = accountRepository;
            _userRepository = userRepository;
            _transactionRepository = transactionRepository;
        }
        public async Task<TransferResponseDTO> TransferAsync(string appUserId, string iban, decimal amount, string lastNumbers)
        {
            var lookup = await findAccount(appUserId, lastNumbers);
            if (!lookup.Success)
                return new TransferResponseDTO { message = lookup.ErrorMessage };

            var fromAccount = lookup.Account!;
            var appUser = lookup.AppUser!;
            if (fromAccount.Balance < amount)
            {
                return new TransferResponseDTO
                {
                    message = "Insufficient funds"
                };
            }
            var resultOfCheck = checkLimit(fromAccount, amount);
            if (resultOfCheck.Item1 == false)
            {
                return new TransferResponseDTO
                {
                    message = $"You can transfer only {resultOfCheck.Item2} for today"
                };
            }
            
            var toAccount = await _accountRepository.GetAccountByIban(iban);
            if (toAccount == null)
            {
                return new TransferResponseDTO
                {
                    message = "Recipient account was not found"
                };
            }
            using (var tx = await _transactionRepository.BeginTransactionAsync())
            {
                try
                {
                    toAccount.Deposit(amount);
                    fromAccount.TransferOut(amount);
                    fromAccount.TransferredLastDay += amount;
                    fromAccount.LastTransferDateKz = KazToday;
                    var transaction = new Transaction
                    {
                        Id = Guid.NewGuid(),
                        From = fromAccount.Iban.ToString(),
                        To = toAccount.Iban.ToString(),
                        ClientId = appUser!.Client.Id,
                        Amount = amount,
                        CreatedAt = DateTime.UtcNow,
                        Type = "Transfer"
                    };
                    await _transactionRepository.AddTransaction(transaction);
                    await _userRepository.SaveChangesAsync();

                    await tx.CommitAsync();
                }
                catch
                {
                    await tx.RollbackAsync();
                    throw;
                }
            }

            return new TransferResponseDTO
            {
                Full_name = toAccount.Client.FullName,
                transferredAmount = amount,
                remainingBalance = fromAccount.Balance
            };

        }
        private (bool, decimal?) checkLimit(Account account, decimal amount)
        {
            if (account.LastTransferDateKz != KazToday)
            {
                account.TransferredLastDay = 0m;
                account.LastTransferDateKz = KazToday;
            }
            if (account.TransferredLastDay + amount > daily_limit)
            {
                var canDeposit = daily_limit - account.TransferredLastDay;
                return (false, canDeposit);
            }
            return (true, null);
        }
        private async Task<AccountLookupResult> findAccount(string appUserId, string lastNumbers)
        {
            if (!Guid.TryParse(appUserId, out var appUserGuid))
                return AccountLookupResult.Fail("Invalid user id format");

            var appUser = await _appUserRepository.GetAppUserAsync(appUserGuid);
            if (appUser == null)
                return AccountLookupResult.Fail("AppUser was not found");

            var card = await _accountRepository.GetRequisitesDTOAsync(appUser.Client.Id, lastNumbers);
            if (card == null)
                return AccountLookupResult.Fail("Card was not found");

            var account = await _accountRepository.GetAccountById(card.AccountId);
            if (account == null)
                return AccountLookupResult.Fail("Account was not found");

            return AccountLookupResult.Ok(account, appUser);
        }
        private class AccountLookupResult
        {
            public bool Success { get; private set; }
            public string? ErrorMessage { get; private set; }
            public Account? Account { get; private set; }
            public AppUser? AppUser { get; private set; }

            private AccountLookupResult() { }

            public static AccountLookupResult Fail(string message) =>
                new AccountLookupResult { Success = false, ErrorMessage = message };

            public static AccountLookupResult Ok(Account account, AppUser appUser) =>
                new AccountLookupResult { Success = true, Account = account, AppUser = appUser };
        }
    }
}

using Application.DTO.AppUserDTO;
using Application.Validators.CustomValidation;
using FluentValidation;
using System.Data;
namespace Application.Validators.AppUserValidators
{
    public class AppUserValidator : AbstractValidator<AppUserCreateDTO>
    {
        public AppUserValidator()
        {
            RuleFor(user => user.Email).EmailRule();

            RuleFor(user => user.IIN).IINRule();

            RuleFor(user => user.PinCode).PinCodeRule();

            RuleFor(user => user.PasswordHash).PasswordRule();

        }
    }
}

using Application.DTO.AuthDTO;
using Application.Validators.CustomValidation;
using FluentValidation;
using System.Data;

namespace Application.Validators.AppUserValidators
{
    public class LoginViaPasswordValidator : AbstractValidator<LoginViaPasswordDTO>
    {
        public LoginViaPasswordValidator()
        {
            RuleFor(x => x.Email).EmailRule();
            RuleFor(x => x.Password).PasswordRule();
        }
    }
}

using Application.DTO.AuthDTO;
using FluentValidation;
using Application.Validators.CustomValidation;
namespace Application.Validators.AppUserValidators
{
    public class LoginViaPinValidator : AbstractValidator<LoginViaPinDTO>
    {
        public LoginViaPinValidator()
        {
            RuleFor(x => x.Email).EmailRule();
            RuleFor(x => x.PinCode).PinCodeRule();
        }
    }
}

using Application.DTO.CardDTO;
using Application.Validators.CustomValidation;
using FluentValidation;
namespace Application.Validators.CardValidators
{
    public class LastNumberValidator : AbstractValidator<LastNumbersDTO>
    {
        public LastNumberValidator()
        {
            RuleFor(x => x.LastNumbers).LastNumbersRule();
        }
    }
}

using Application.DTO.ClientDTO;
using Application.Validators.CustomValidation;
using FluentValidation;
namespace Application.Validators.ClientValidators
{
    public class ClientValidator : AbstractValidator<ClientCreateDTO>
    {
        public ClientValidator()
        {
            RuleFor(client => client.IIN).IINRule();
            RuleFor(client => client.FullName)
                .NotNull().WithMessage("Full Name is required.")
                .Matches("^[a-zA-Zа-яА-ЯёЁ\\s'-]+$").WithMessage("Full Name can only contain letters, spaces, hyphens, and apostrophes.");
            RuleFor(client => client.PhoneNumber)
                .NotEmpty().WithMessage("Phone Number is required.")
                .Matches(@"^\+?[1-9]\d{1,14}$").WithMessage("Phone Number must be in a valid format.");
        }
    }
}

using FluentValidation;
using Application.Validators.CustomValidation;
using Application.DTO.ClientDTO;
namespace Application.Validators.ClientValidators
{
    public class IINValidator : AbstractValidator<IINDTO>
    {
        public IINValidator()
        {
            RuleFor(c => c.IIN).IINRule();
        }
    }
}

using FluentValidation;
namespace Application.Validators.CustomValidation
{
    public static class CustomValidationRules
    {
        public static IRuleBuilderOptions<T, string> EmailRule<T>(this IRuleBuilder<T, string> ruleBuilder)
        {
            return ruleBuilder
                .NotEmpty().WithMessage("Email is required.")
                .EmailAddress().WithMessage("Invalid email format.");
        }
        public static IRuleBuilderOptions<T, string> IINRule<T>(this IRuleBuilder<T, string> ruleBuilder)
        {
            return ruleBuilder
                .NotEmpty().WithMessage("IIN is required.")
                .Length(12).WithMessage("IIN must be exactly 12 characters long.")
                .Matches("^[0-9]{12}$").WithMessage("IIN must contain only digits.");
        }
        public static IRuleBuilderOptions<T, string> PasswordRule<T>(this IRuleBuilder<T, string> ruleBuilder)
        {
            return ruleBuilder
                .NotEmpty().WithMessage("Password is required.")
                .MinimumLength(6).WithMessage("Password must be at least 6 characters long.")
                .Matches("[A-Z]").WithMessage("Password must contain at least one uppercase letter.")
                .Matches("[a-z]").WithMessage("Password must contain at least one lowercase letter.")
                .Matches("[0-9]").WithMessage("Password must contain at least one digit.")
                .Matches("[^a-zA-Z0-9]").WithMessage("Password must contain at least one special character.");
        }
        public static IRuleBuilderOptions<T, string> PinCodeRule<T>(this IRuleBuilder<T, string> ruleBuilder)
        {
            return ruleBuilder
                .NotEmpty().WithMessage("PinCode is required.")
                .Length(4).WithMessage("PinCode must be exactly 4 characters long.")
                .Matches("^[0-9]{4}$").WithMessage("PinCode must contain only digits.");
        }
        public static IRuleBuilderOptions<T, string> LastNumbersRule<T>(this IRuleBuilder<T, string> ruleBuilder)
        {
            return ruleBuilder
                .NotEmpty().WithMessage("Last numbers should not be empty")
                .Length(4).WithMessage("Last numbers should be exactly 4 digits")
                .Matches("^[0-9]{4}$").WithMessage("Last numbers should contain only digits");
        }
        public static IRuleBuilderOptions<T, decimal> AmountRule<T>(this IRuleBuilder<T, decimal> ruleBuilder)
        {
            return ruleBuilder
                .NotEmpty().WithMessage("Amount is empty")
                .GreaterThan(0).WithMessage("Amount must be greater than 0")
                .LessThan(2000000m).WithMessage("Amount must be less than 2 000 000");
        }
        public static IRuleBuilderOptions<T, string> IbanRule<T>(this IRuleBuilder<T, string> ruleBuilder)
        {
            return ruleBuilder
                .NotEmpty().WithMessage("IBAN is required.")
                .Length(21).WithMessage("IBAN must be exactly 21 characters long.")
                .Matches(@"^KZ[0-9]{2}[A-Z]{4}[0-9]{13}$").WithMessage("IBAN must start with 'KZ', then 2 digits, 4 letters (bank code), and 13 digits.");
        }
    }
}

using Application.DTO.TransactionDTO;
using FluentValidation;
using Application.Validators.CustomValidation;
namespace Application.Validators.TransactionQueryValidators
{
    public class DepositQueryValidator : AbstractValidator<DepositQueryDTO>
    {
        public DepositQueryValidator()
        {
            RuleFor(x => x.Amount).AmountRule();
            RuleFor(x => x.LastNumbers).LastNumbersRule();
        }
    }
}

using Application.DTO.TransactionDTO;
using FluentValidation;
using Application.Validators.CustomValidation;
namespace Application.Validators.TransactionQueryValidators
{
    public class TransferQueryValidator : AbstractValidator<TransferQueryDTO>
    {
        public TransferQueryValidator()
        {
            RuleFor(a => a.Amount).AmountRule();    
            RuleFor(a => a.LastNumbers).LastNumbersRule();
            RuleFor(a => a.Iban).IbanRule();
        }
    }
}

using Application.Interfaces.Services;
using Microsoft.AspNetCore.Mvc;
using Domain.Enums;
using Application.DTO.AppUserDTO;
using Application.DTO.ClientDTO;
namespace BankSystemAPI.Controllers
{
    [ApiController]
    [Route("api/app-users")]
    public class AppUserController : ControllerBase
    {
        private readonly IAppUserService _appUserService;
        private readonly ILogger<AppUserController> _logger;
        public AppUserController(IAppUserService appUserService, ILogger<AppUserController> logger)
        {
            _appUserService = appUserService;
            _logger = logger;
        }
        [HttpPost]
        public async Task<ActionResult<RegistrationStatusDTO>> CreateAppUser([FromBody] AppUserCreateDTO appUserDTO)
        {
            _logger.LogInformation("Creating new app-user... {email}", appUserDTO.Email);
            var result = await _appUserService.RegisterAppUser(appUserDTO);
            if (result.VerificationStatus == VerificationStatus.Rejected.ToString())
            {
                _logger.LogWarning("App-user {email} could not register - {info}", appUserDTO.Email, result.Message);
                return Conflict(result);
            }
            _logger.LogInformation("App-user created successfully - {email}", appUserDTO.Email);    
            return CreatedAtAction(null, result);
        }
    }
}

using Application.DTO.AuthDTO;
using Application.Interfaces.Services;
using Domain.Enums;
using Microsoft.AspNetCore.Mvc;
using System.Runtime.CompilerServices;


namespace BankSystemAPI.Controllers
{
    [ApiController]
    [Route("api/auth")]
    public class AuthController : ControllerBase
    {
        private readonly IAuthService _authService;
        private readonly ILogger<AuthController> _logger;
        public AuthController(IAuthService authService, ILogger<AuthController> logger)
        {
            _authService = authService;
            _logger = logger;
        }
        [HttpPost("login/pin")]
        public async Task<ActionResult<LoginStatusDTO>> LoginViaPin([FromBody] LoginViaPinDTO loginViaPinDTO)
        {
            _logger.LogInformation("App-user attempting to log in via PIN... {email}", loginViaPinDTO.Email);
            var result = await _authService.LoginPin(loginViaPinDTO.Email!, loginViaPinDTO.PinCode);
            if (result.VerificationStatus == VerificationStatus.Rejected.ToString())
            {
                _logger.LogWarning("App-user {email} could not log in via PIN - {info}", loginViaPinDTO.Email, result.Message);
                return BadRequest(result);
            }
            else
            {
                Response.Cookies.Append("refreshToken", result.RefreshToken, new CookieOptions
                {
                    Expires = DateTimeOffset.UtcNow.AddDays(5)
                });
                _logger.LogInformation("App-user logged in successfully via PIN - {email}", loginViaPinDTO.Email);
                return Ok(result);
            }
        }
        [HttpPost("login/password")]
        public async Task<ActionResult<LoginStatusDTO>> LoginViaPassword([FromBody] LoginViaPasswordDTO loginViaPasswordDTO)
        {
            _logger.LogInformation("App-user attempting to log in via Password... {email}", loginViaPasswordDTO.Email);
            var result = await _authService.LoginPassword(loginViaPasswordDTO.Email!, loginViaPasswordDTO.Password);
            if (result.VerificationStatus == VerificationStatus.Rejected.ToString())
            {
                _logger.LogWarning("App-user {email} could not log in via Password - {info}", loginViaPasswordDTO.Email, result.Message);
                return BadRequest(result);
            }
            else
            {
                Response.Cookies.Append("refreshToken", result.RefreshToken, new CookieOptions
                {
                    Expires = DateTimeOffset.UtcNow.AddDays(5)
                });
                _logger.LogInformation("App-user logged in successfully via Password - {email}", loginViaPasswordDTO.Email);
                return Ok(result);
            }
        }
        [HttpPost("refresh")]
        public async Task<ActionResult<LoginStatusDTO>> RefreshToken()
        {
            _logger.LogInformation("App-user attempting to refresh token...");
            var result = await _authService.RefreshToken();
            if (result.VerificationStatus == VerificationStatus.Rejected.ToString())
            {
                _logger.LogWarning("App-user could not refresh token - {info}", result.Message);
                return Unauthorized(result);
            }
            _logger.LogInformation("App-user refreshed token successfully");
            return Ok(result);
        }
    }
}

using System.Data;
using System.IdentityModel.Tokens.Jwt;
using System.Security.Claims;
using Application.DTO.CardDTO;
using Application.Interfaces.Services;
using Microsoft.AspNetCore.Authorization;
using Microsoft.AspNetCore.Mvc;

namespace BankSystemAPI.Controllers
{
    [ApiController]
    [Route("api/card")]
    public class CardController : ControllerBase
    {
        private readonly IGetCardService _getCardService;
        private readonly IGetRequisitesOfCardService _getRequisitesOfCardService;
        private readonly ILogger<CardController> _logger;
        public CardController(IGetCardService getCardService, IGetRequisitesOfCardService getRequisitesOfCard, ILogger<CardController> logger)
        {
            _getCardService = getCardService;
            _getRequisitesOfCardService = getRequisitesOfCard;
            _logger = logger;
        }
        [Authorize]
        [HttpGet("getAllCards")]
        public async Task<ActionResult<IEnumerable<GetCardDTO>>> GetAllCards()
        {
            _logger.LogInformation("Fetching all cards for the authenticated user.");
            if (User?.Identity == null || !User.Identity.IsAuthenticated)
                return Unauthorized("No token or not authenticated");
            _logger.LogInformation("User is authenticated.");
            _logger.LogInformation("Attempt to get id of user...");
            var appUserIdClaim = User.FindFirst(JwtRegisteredClaimNames.Sub)?.Value
                                  ?? User.FindFirst(ClaimTypes.NameIdentifier)?.Value;

            if (!Guid.TryParse(appUserIdClaim, out var appUserGuid))
                return BadRequest("Invalid user id format");
            _logger.LogInformation("Attempt to get all cards of user...");
            var cards = await _getCardService.GetAllCards(appUserIdClaim ?? throw new Exception("NoId"));
            if (cards != null)
            {
                _logger.LogInformation("Cards retrieved successfully.");
                return Ok(cards);
            }
            _logger.LogWarning("No cards found for the user.");
            return NotFound();
        }
        [Authorize]
        [HttpGet("getRequisitesCards")]
        public async Task<ActionResult<CardRequisitesDTO>> GetRequisites([FromQuery] LastNumbersDTO lastNumbersDTO)
        {
            _logger.LogInformation("Fetching card requisites for the authenticated user.");
            if (User?.Identity == null || !User.Identity.IsAuthenticated)
                return Unauthorized("No token or not authenticated");

            var appUserIdClaim = User.FindFirst(JwtRegisteredClaimNames.Sub)?.Value
                                  ?? User.FindFirst(ClaimTypes.NameIdentifier)?.Value;

            var card = await _getRequisitesOfCardService.GetRequisitesOfCard(appUserIdClaim ?? throw new Exception("AppUser id is not here"), lastNumbersDTO.LastNumbers);
            if (card == null)
            {
                _logger.LogWarning("Card not found with the provided last numbers.");
                return NotFound("Card was not found");
            }
            _logger.LogInformation("Card requisites retrieved successfully.");
            return Ok(card);
        }
    }
    
}


using Application.DTO.ClientDTO;
using Application.Interfaces.Services;
using Domain.Enums;
using Microsoft.AspNetCore.Mvc;

namespace BankSystemAPI.Controllers
{
    [ApiController]
    [Route("api/clients")]
    public class ClientController : ControllerBase
    {
        private readonly IClientService _clientService;
        private readonly ILogger<ClientController> _logger;
        public ClientController(IClientService clientService, ILogger<ClientController> logger)
        {
            _clientService = clientService;
            _logger = logger;
        }
        [HttpPost]
        public async Task<ActionResult<RegistrationStatusDTO>> CreateClient([FromBody] ClientCreateDTO clientDTO)
        {
            _logger.LogInformation("Creating new client... {full name}", clientDTO.FullName);
            var result = await _clientService.Register(clientDTO);
            if (result.KycStatus == KycStatus.Rejected.ToString())
            {
                _logger.LogWarning("Client {full name} could not register - {info}", clientDTO.FullName, result.Message);
                return Conflict(result);
            }
            _logger.LogInformation("Client created successfully - {full name}", clientDTO.FullName);
            return CreatedAtAction(null, result);
        }
        [HttpDelete("{iin}")]
        public async Task<IActionResult> Delete([FromQuery] IINDTO iinDTO)
        {
            _logger.LogInformation("Attempting to delete client with IIN: {iin}", iinDTO.IIN);
            bool result = await _clientService.DeleteClient(iinDTO.IIN);
            if (result == false)
            {
                _logger.LogWarning("Client with IIN: {iin} was not found", iinDTO.IIN);
                return NotFound("Client was not found");
            }
            else
            {
                _logger.LogInformation("Client with IIN: {iin} deleted successfully", iinDTO.IIN);
                return NoContent();
            }
        }
    }
}

using Application.DTO.TransactionDTO;
using Application.Interfaces.Services;
using Microsoft.AspNetCore.Authorization;
using Microsoft.AspNetCore.Mvc;
using System.IdentityModel.Tokens.Jwt;
using System.Security.Claims;

namespace BankSystemAPI.Controllers
{
    [ApiController]
    [Route("transaction")]
    public class TransactionController : ControllerBase
    {
        private readonly IDepositService _depositService;
        private readonly ITransferService _transferService;
        private readonly ILogger<TransactionController> _logger;
        public TransactionController(IDepositService depositService
            ,ITransferService transferService
            ,ILogger<TransactionController> logger)
        {
            _depositService = depositService;
            _transferService = transferService;
            _logger = logger;
        }
        [Authorize]
        [HttpPost("deposit")]
        public async Task<ActionResult<DepositResponseDTO>> Deposit([FromBody] DepositQueryDTO depositQueryDTO)
        {
            if (User?.Identity == null || !User.Identity.IsAuthenticated)
            {
                _logger.LogInformation("User is not authenticated.");
                return new DepositResponseDTO
                { 
                    message = "User is not authenticated"
                };
            }
            var appUserIdClaim = User.FindFirst(JwtRegisteredClaimNames.Sub)?.Value
                                  ?? User.FindFirst(ClaimTypes.NameIdentifier)?.Value;
            var result = await _depositService.DepositAsync(depositQueryDTO.Amount, appUserIdClaim!, depositQueryDTO.LastNumbers);
            if (result.depositedAmount == null)
            {
                _logger.LogWarning("Deposit failed: {message}", result.message);
                return BadRequest(result.message);
            }
            _logger.LogInformation("Deposit successful: {depositedAmount}", result.depositedAmount);
            return Ok(result);
        }
        [Authorize]
        [HttpPost("transfer")]
        public async Task<ActionResult<TransferResponseDTO>> Transfer([FromBody] TransferQueryDTO transferQueryDTO)
        {
            if (User?.Identity == null || !User.Identity.IsAuthenticated)
            {
                _logger.LogInformation("User is not authenticated.");
                return new TransferResponseDTO
                {
                    message = "User is not authenticated"
                };
            }
            var appUserIdClaim = User.FindFirst(JwtRegisteredClaimNames.Sub)?.Value
                                  ?? User.FindFirst(ClaimTypes.NameIdentifier)?.Value;
            var result = await _transferService.TransferAsync(appUserIdClaim!
                ,transferQueryDTO.Iban
                ,transferQueryDTO.Amount
                ,transferQueryDTO.LastNumbers);
            if (result.transferredAmount == null)
            {
                _logger.LogWarning("Transfer failed: {message}", result.message);
                return BadRequest(result.message);
            }
            _logger.LogInformation("Transfer successful: {transferredAmount}", result.transferredAmount);
            return Ok(result);
        }
    }
}

using System.Text;
using Domain.Configuration;
using Microsoft.AspNetCore.Authentication.JwtBearer;
using Microsoft.Extensions.Options;
using Microsoft.IdentityModel.Tokens;

namespace BankSystemAPI.Extensions
{
    public static class ApiExtensions
    {
        public static void AddApiAuthentication(this IServiceCollection services, IConfiguration configuration)
        {
            var section = configuration.GetSection("JwtOptions");
            services.Configure<JwtOptions>(section);

            var jwtOptions = section.Get<JwtOptions>() ?? new JwtOptions();
            jwtOptions.SecretKey = Environment.GetEnvironmentVariable("JWT_SECRET")
                                    ?? throw new InvalidOperationException("Jwt secret not set");

            services.AddAuthentication(JwtBearerDefaults.AuthenticationScheme)
                .AddJwtBearer(options =>
                {
                    options.TokenValidationParameters = new TokenValidationParameters
                    {
                        ValidateIssuer = true,
                        ValidateAudience = true,
                        ValidateLifetime = true,
                        ValidateIssuerSigningKey = true,
                        ValidIssuer = jwtOptions.Issuer,
                        ValidAudience = jwtOptions.Audience,
                        IssuerSigningKey = new SymmetricSecurityKey(Encoding.UTF8.GetBytes(jwtOptions.SecretKey))
                    };
                    options.Events = new JwtBearerEvents
                    {
                        OnAuthenticationFailed = ctx =>
                        {
                            Console.WriteLine($"[AUTH FAILED] {ctx.Exception.Message}");
                            return Task.CompletedTask;
                        },
                        OnChallenge = ctx =>
                        {
                            Console.WriteLine("[AUTH CHALLENGE] Token missing or invalid");
                            return Task.CompletedTask;
                        },
                        OnTokenValidated = ctx =>
                        {
                            Console.WriteLine("[AUTH SUCCESS] Token validated");
                            return Task.CompletedTask;
                        }
                    };
                });
            
            services.AddAuthorization();
        }
    }
}

using System.Diagnostics;

namespace BankSystemAPI.Middlewares
{
    public class LoggerMiddleware
    {
        private readonly ILogger<LoggerMiddleware> _logger;
        private readonly RequestDelegate _next;
        public LoggerMiddleware(ILogger<LoggerMiddleware> logger, RequestDelegate next)
        {
            _logger = logger;
            _next = next;
        }
        public async Task InvokeAsync(HttpContext context)
        {
            var stopwatch = Stopwatch.StartNew();
            try
            {
                var method = context.Request.Method;
                var path = context.Request.Path;
                var host = context.Request.Headers["Host"].ToString();
                _logger.LogInformation("Incoming Request: {Method} {Path} {host}", method, path, host);
                await _next(context);
                stopwatch.Stop();
                var statusCode = context.Response.StatusCode;
                _logger.LogInformation("Outgoing Response: {Method} {Path} responded {StatusCode} in {ElapsedMilliseconds}ms", method, path, statusCode, stopwatch.ElapsedMilliseconds);
            }
            catch (Exception ex)
            {
                stopwatch.Stop();
                var method = context.Request.Method;
                var path = context.Request.Path;
                _logger.LogError(ex, "An unhandled exception occurred while processing the request {method} - {path} in {ElapsedMilliseconds}ms", method, path, stopwatch.ElapsedMilliseconds);
                throw;
            }
        }
    }
}

// <autogenerated />
using System;
using System.Reflection;
[assembly: global::System.Runtime.Versioning.TargetFrameworkAttribute(".NETCoreApp,Version=v9.0", FrameworkDisplayName = ".NET 9.0")]

//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Runtime Version:4.0.30319.42000
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

using System;
using System.Reflection;

[assembly: System.Reflection.AssemblyCompanyAttribute("BankSystem")]
[assembly: System.Reflection.AssemblyConfigurationAttribute("Debug")]
[assembly: System.Reflection.AssemblyFileVersionAttribute("1.0.0.0")]
[assembly: System.Reflection.AssemblyInformationalVersionAttribute("1.0.0")]
[assembly: System.Reflection.AssemblyProductAttribute("BankSystem")]
[assembly: System.Reflection.AssemblyTitleAttribute("BankSystem")]
[assembly: System.Reflection.AssemblyVersionAttribute("1.0.0.0")]

// Generated by the MSBuild WriteCodeFragment class.


// <auto-generated/>
global using global::Microsoft.AspNetCore.Builder;
global using global::Microsoft.AspNetCore.Hosting;
global using global::Microsoft.AspNetCore.Http;
global using global::Microsoft.AspNetCore.Routing;
global using global::Microsoft.Extensions.Configuration;
global using global::Microsoft.Extensions.DependencyInjection;
global using global::Microsoft.Extensions.Hosting;
global using global::Microsoft.Extensions.Logging;
global using global::System;
global using global::System.Collections.Generic;
global using global::System.IO;
global using global::System.Linq;
global using global::System.Net.Http;
global using global::System.Net.Http.Json;
global using global::System.Threading;
global using global::System.Threading.Tasks;

//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Runtime Version:4.0.30319.42000
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

using System;
using System.Reflection;

[assembly: Microsoft.AspNetCore.Mvc.ApplicationParts.ApplicationPartAttribute("FluentValidation.AspNetCore")]
[assembly: Microsoft.AspNetCore.Mvc.ApplicationParts.ApplicationPartAttribute("Microsoft.AspNetCore.OpenApi")]
[assembly: Microsoft.AspNetCore.Mvc.ApplicationParts.ApplicationPartAttribute("Swashbuckle.AspNetCore.SwaggerGen")]

// Generated by the MSBuild WriteCodeFragment class.


//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Runtime Version:4.0.30319.42000
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

using System;
using System.Reflection;

[assembly: System.Reflection.AssemblyCompanyAttribute("BankSystemAPI")]
[assembly: System.Reflection.AssemblyConfigurationAttribute("Debug")]
[assembly: System.Reflection.AssemblyFileVersionAttribute("1.0.0.0")]
[assembly: System.Reflection.AssemblyInformationalVersionAttribute("1.0.0+89d32106120063aadf12636df3d6a97522ccdea6")]
[assembly: System.Reflection.AssemblyProductAttribute("BankSystemAPI")]
[assembly: System.Reflection.AssemblyTitleAttribute("BankSystemAPI")]
[assembly: System.Reflection.AssemblyVersionAttribute("1.0.0.0")]

// Generated by the MSBuild WriteCodeFragment class.


// <auto-generated/>
global using global::Microsoft.AspNetCore.Builder;
global using global::Microsoft.AspNetCore.Hosting;
global using global::Microsoft.AspNetCore.Http;
global using global::Microsoft.AspNetCore.Routing;
global using global::Microsoft.Extensions.Configuration;
global using global::Microsoft.Extensions.DependencyInjection;
global using global::Microsoft.Extensions.Hosting;
global using global::Microsoft.Extensions.Logging;
global using global::System;
global using global::System.Collections.Generic;
global using global::System.IO;
global using global::System.Linq;
global using global::System.Net.Http;
global using global::System.Net.Http.Json;
global using global::System.Threading;
global using global::System.Threading.Tasks;

//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Runtime Version:4.0.30319.42000
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

using System;
using System.Reflection;

[assembly: Microsoft.AspNetCore.Mvc.ApplicationParts.ApplicationPartAttribute("FluentValidation.AspNetCore")]
[assembly: Microsoft.AspNetCore.Mvc.ApplicationParts.ApplicationPartAttribute("Microsoft.AspNetCore.OpenApi")]
[assembly: Microsoft.AspNetCore.Mvc.ApplicationParts.ApplicationPartAttribute("Swashbuckle.AspNetCore.SwaggerGen")]

// Generated by the MSBuild WriteCodeFragment class.


// <autogenerated />
using System;
using System.Reflection;
[assembly: global::System.Runtime.Versioning.TargetFrameworkAttribute(".NETCoreApp,Version=v9.0", FrameworkDisplayName = ".NET 9.0")]

//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Runtime Version:4.0.30319.42000
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

using System;
using System.Reflection;

[assembly: System.Reflection.AssemblyCompanyAttribute("BankSystemAPI")]
[assembly: System.Reflection.AssemblyConfigurationAttribute("Release")]
[assembly: System.Reflection.AssemblyFileVersionAttribute("1.0.0.0")]
[assembly: System.Reflection.AssemblyInformationalVersionAttribute("1.0.0+ba47c6a8ad9d8ab08ed9550af9048b5c55076af1")]
[assembly: System.Reflection.AssemblyProductAttribute("BankSystemAPI")]
[assembly: System.Reflection.AssemblyTitleAttribute("BankSystemAPI")]
[assembly: System.Reflection.AssemblyVersionAttribute("1.0.0.0")]

// Generated by the MSBuild WriteCodeFragment class.


// <auto-generated/>
global using global::Microsoft.AspNetCore.Builder;
global using global::Microsoft.AspNetCore.Hosting;
global using global::Microsoft.AspNetCore.Http;
global using global::Microsoft.AspNetCore.Routing;
global using global::Microsoft.Extensions.Configuration;
global using global::Microsoft.Extensions.DependencyInjection;
global using global::Microsoft.Extensions.Hosting;
global using global::Microsoft.Extensions.Logging;
global using global::System;
global using global::System.Collections.Generic;
global using global::System.IO;
global using global::System.Linq;
global using global::System.Net.Http;
global using global::System.Net.Http.Json;
global using global::System.Threading;
global using global::System.Threading.Tasks;

using Application.Interfaces;
using Application.Interfaces.Auth;
using Application.Interfaces.Repositories;
using Application.Interfaces.Services;
using Application.Mappings;
using Application.Services.AccountServices;
using Application.Services.AppUserServices;
using Application.Services.AuthServices;
using Application.Services.CardServices;
using Application.Services.ClientServices;
using Application.Services.TransactionServices;
using Application.Validators.AppUserValidators;
using Application.Validators.CardValidators;
using Application.Validators.ClientValidators;
using Application.Validators.TransactionQueryValidators;
using BankSystemAPI.Extensions;
using BankSystemAPI.Middlewares;
using Domain.Configuration;
using FluentValidation;
using FluentValidation.AspNetCore;
using Infrastructure;
using Infrastructure.DbContext; 
using Infrastructure.JWT;
using Infrastructure.PanServices;
using Infrastructure.Repositories;
using Microsoft.AspNetCore.CookiePolicy;
using Microsoft.AspNetCore.Diagnostics;
using Microsoft.EntityFrameworkCore;
using Microsoft.OpenApi.Models;
using Serilog;

var builder = WebApplication.CreateBuilder(args);

builder.Services.AddEndpointsApiExplorer();

builder.Services.AddControllers();
builder.Services.AddSwaggerGen(c =>
{
    c.SwaggerDoc("v1", new OpenApiInfo { Title = "Bank API", Version = "v1" });

    c.AddSecurityDefinition("Bearer", new OpenApiSecurityScheme
    {
        Name = "Authorization",
        Type = SecuritySchemeType.ApiKey,
        Scheme = "Bearer",
        BearerFormat = "JWT",
        In = ParameterLocation.Header,
        Description = "Введите токен в формате: Bearer {твой токен}"
    });

    c.AddSecurityRequirement(new OpenApiSecurityRequirement
    {
        {
            new OpenApiSecurityScheme
            {
                Reference = new OpenApiReference
                {
                    Type = ReferenceType.SecurityScheme,
                    Id = "Bearer"
                }
            },
            Array.Empty<string>()
        }
    });
});
Log.Logger = LoggingConfiguration.CreateLogger("Logs/log-.txt");
builder.Host.UseSerilog();
builder.Services.AddScoped<IAppUserService, AppUserService>();
builder.Services.AddScoped<IAuthService, AuthService>();
builder.Services.AddScoped<IClientService, ClientService>();
builder.Services.AddScoped<ITokenService, TokenService>();
builder.Services.AddScoped<IUserRepository, UserRepository>();
builder.Services.AddScoped<IHasher, Hasher>();
builder.Services.AddScoped<IClientRepository, ClientRepository>();
builder.Services.AddScoped<IAuthRepository, AuthRepository>();
builder.Services.AddScoped<IGetRequisitesOfCardService, GetRequisitesOfCardService>();
builder.Services.AddScoped<IAppUserRepository, AppUserRepository>();
builder.Services.AddScoped<ITransferService, TransferService>();
builder.Services.AddScoped<IAccountRepository, AccountRepository>();
builder.Services.AddScoped<IAccountService, AccountService>();
builder.Services.AddScoped<ICardService, CardService>();
builder.Services.AddScoped<IGetCardService, GetCardService>();
builder.Services.AddScoped<IPanService, Pan_generation>();
builder.Services.AddScoped<ITransactionRepository, TransactionRepository>();
builder.Services.AddScoped<IDepositService, DepositService>();
builder.Services.AddScoped<IIBanService, IbanService>();
builder.Logging.AddConsole();

builder.Services.AddFluentValidationAutoValidation()
    .AddFluentValidationClientsideAdapters();
builder.Services.AddValidatorsFromAssemblyContaining<ClientValidator>();
builder.Services.AddValidatorsFromAssemblyContaining<AppUserValidator>();
builder.Services.AddValidatorsFromAssemblyContaining<LoginViaPasswordValidator>();
builder.Services.AddValidatorsFromAssemblyContaining<LoginViaPinValidator>();
builder.Services.AddValidatorsFromAssemblyContaining<LastNumberValidator>();
builder.Services.AddValidatorsFromAssemblyContaining<IINValidator>();
builder.Services.AddValidatorsFromAssemblyContaining<TransferQueryValidator>();
builder.Services.AddValidatorsFromAssemblyContaining<DepositQueryValidator>();
builder.Services.AddAutoMapper(typeof(MappingProfile));
builder.Services.AddHttpContextAccessor();
builder.Services.Configure<RefreshTokenOptions>(
        builder.Configuration.GetSection("RefreshJwtOptions")
    );
builder.Services.Configure<JwtOptions>(opts =>
{
    builder.Configuration.GetSection("JwtOptions").Bind(opts);
    opts.SecretKey = Environment.GetEnvironmentVariable("JWT_SECRET")
        ?? throw new InvalidOperationException("Jwt secret not set");
});

builder.Services.AddApiAuthentication(builder.Configuration);

builder.Services.AddDbContext<AppDbContext>(options =>  
    options.UseNpgsql("Host = localhost; Port = 5432; Database = BankSystem; Username = postgres; Password = 210624"));
builder.Services.AddScoped<IJwtProvider, JwtProvider>();
builder.Services.AddScoped<IRefreshTokenProvider, RefreshTokenProvider>();
builder.Services.AddSingleton<IPanEncryptor>(sp =>
{
    var keyString = builder.Configuration["PanSecretKey:Key"]
                    ?? throw new ArgumentNullException("Pan secret key was not found");

    var key = Convert.FromBase64String(keyString);
    return new PanEncryptor(key);
});
var app = builder.Build();
if (app.Environment.IsDevelopment())
    {
        app.UseSwagger();
        app.UseSwaggerUI(options =>
        {
            options.SwaggerEndpoint("/swagger/v1/swagger.json", "My Bank API");
        });
}
app.UseMiddleware<LoggerMiddleware>();
app.UseExceptionHandler(context => {
    context.Run(async content =>
    {
        content.Response.StatusCode = 500;
        content.Response.ContentType = "application/json";
        var box = content.Features.Get<IExceptionHandlerPathFeature>();
        var error = box?.Error;

        var logget = app.Services.GetRequiredService<ILogger<Program>>();
        logget.LogError(error, "Unhandled exception: {message}", error?.Message);
        var Error = new
        {
            Topic = "Unhandled exception",
            message = error?.Message
        };
        string message = System.Text.Json.JsonSerializer.Serialize(Error);
        await content.Response.WriteAsync(message);
    });
});
app.UseCookiePolicy(new CookiePolicyOptions
{
    HttpOnly = HttpOnlyPolicy.Always,
    Secure = CookieSecurePolicy.Always,
    MinimumSameSitePolicy = SameSiteMode.Strict,
});
app.UseAuthentication();
app.UseAuthorization();
app.MapControllers();
app.Run();

namespace Domain.Configuration
{
    public class JwtOptions
    {
        public string Issuer { get; set; } = null!;
        public string Audience { get; set; } = null!;
        public string SecretKey { get; set; } = null!;
        public int ExpireMinutes { get; set; }
    }

}

namespace Domain.Configuration
{
    public class RefreshTokenOptions
    {
        public int ExpireDays { get; set; }
    }
}

namespace Domain.Enums
{
    public enum AccountType
    {
        Current = 100,  
        Deposit = 200,   
        Loan = 300,      
        Card = 400
    }
}


namespace Domain.Enums
{
    public enum CardStatus 
    {
        Active = 0,       
        Blocked = 1,   
        Expired = 2,      
        Pending = 3,      
        Closed = 4
    }
}


namespace Domain.Enums
{
    public enum CardType
    {
        Debit = 100,        
        Credit = 200,      
        Prepaid = 300,      
        Virtual = 400,     
        Corporate = 500,    
        Gift = 600,
    }
}


namespace Domain.Enums
{
    public enum KycStatus
    {   
        NotStarted = 0,
        Pending = 1,
        Verified = 2,
        Rejected = 3
    }
}


namespace Domain.Enums
{
    public enum RoleStatus
    {
        Admin = 0,
        Client = 1,
        Employee = 2,
        Unknown = 3
    }
}


namespace Domain.Enums
{
    public enum VerificationStatus
    {
        NotStarted = 0,
        Pending = 1,
        Verified = 2,
        Rejected = 3
    }
}

namespace Domain.Models
{
    public class Account
    {
        public Guid Id { get; init; } = Guid.NewGuid();
        public Guid ClientId { get; init; }
        public Client Client { get; set; } = null!;
        public string Iban { get; set; } = null!;
        public decimal Balance { get; private set; } = 0;
        public string? Currency { get; } = "KZT";
        public DateOnly LastDepositDateKz { get; set; }
        public decimal? DepositedLastDay { get; set; }
        public DateOnly LastTransferDateKz { get; set; }
        public decimal? TransferredLastDay { get; set; }
        public ICollection<Card> Cards { get; set; } = new List<Card>();
        public void Deposit(decimal amount)
        {
            Balance += amount;
        }
        public void TransferOut(decimal amount)
        {
            Balance -= amount;
        }
    }
}

    using Domain.Enums;

    namespace Domain.Models
    {
        public class AppUser
        {
            public Guid Id { get; init; }
            public required string Email { get; set; }
            public required string PasswordHash { get; set; }
            public bool IsActive { get; set; }
            public VerificationStatus VerificationStatus { get; set; }
            public required Client Client { get; init; }
            public string HashedPinCode { get; set; } = null!;
            public int CountOfLoginAttempts { get; set; } = 0;
            public int CountOfLoginViaPasswordAttempts { get; set; } = 0;   
            public DateTime? BlockedUntil { get; set; }
            public DateTime? BlockedUntilPassword { get; set; }
            public ICollection<RefreshToken> refreshTokens { get; set; } = new List<RefreshToken>();
        }
    }

using Domain.Enums;
namespace Domain.Models
{
    public class Card
    {
        public Guid Id { get; init; } = Guid.NewGuid();
        public Guid AccountId { get; set; }
        public Account Account { get; set; } = null!;
        public string? PanMasked { get; init; }
        public string? ExpiryDate { get; init; }
        public CardStatus? Status { get; set; }       
        public Pan Pan { get; set; } = null!;
        public string? PinCode { get; set; }
        public int CountOfPinAttempts { get; set; } = 0;
    }
}

using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using Domain.Enums;

namespace Domain.Models
{
    public class Client
    {
        public Guid Id { get; init; }
        public required string IIN { get; init; }
        public KycStatus KycStatus { get; set; }
        public string? FullName { get; set; }
        public bool IsDeleted { get; set; }
        public string? PhoneNumber { get; set; }
        public ICollection<Transaction> Transactions { get; set; } = new List<Transaction>();
        public ICollection<Account> Accounts { get; } = new List<Account>();
        public ICollection<AppUser> AppUsers { get; } = new List<AppUser>();
    }
}

using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace Domain.Models
{
    public class Pan
    {
        public Guid Id { get; init; } = Guid.NewGuid();

        public Guid CardId { get; set; }
        public Card Card { get; set; } = null!;
        
        public byte[] CipherText { get; set; } = null!;
        public byte[] Nonce { get; set; } = null!;
        public byte[] Tag { get; set; } = null!;
    }
}


namespace Domain.Models
{
    public class RefreshToken
    {
        public Guid Id { get; init; }
        public required string Token { get; init; }
        public DateTime Expires { get; init; } 
        public Guid UserId { get; init; }  
        public DateTime RevokedAt { get; set; }
        public string? DeviceInfo { get; set; }
        public required AppUser AppUser { get; init; }
    }
}

namespace Domain.Models
{
    public class Transaction
    {
        public Guid Id { get; init; }

        public required string From { get; init; }   
        public required string To { get; init; }
        public Guid ClientId { get; set; }
        public Client Client { get; set; } = null!;
        public decimal Amount { get; init; }
        public string Currency { get; } = "KZT";

        public DateTime CreatedAt { get; init; } = DateTime.UtcNow;
        public string Type { get; set; } = null!;

    }
}

// <autogenerated />
using System;
using System.Reflection;
[assembly: global::System.Runtime.Versioning.TargetFrameworkAttribute(".NETCoreApp,Version=v9.0", FrameworkDisplayName = ".NET 9.0")]

//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Runtime Version:4.0.30319.42000
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

using System;
using System.Reflection;

[assembly: System.Reflection.AssemblyCompanyAttribute("Domain")]
[assembly: System.Reflection.AssemblyConfigurationAttribute("Debug")]
[assembly: System.Reflection.AssemblyFileVersionAttribute("1.0.0.0")]
[assembly: System.Reflection.AssemblyInformationalVersionAttribute("1.0.0+89d32106120063aadf12636df3d6a97522ccdea6")]
[assembly: System.Reflection.AssemblyProductAttribute("Domain")]
[assembly: System.Reflection.AssemblyTitleAttribute("Domain")]
[assembly: System.Reflection.AssemblyVersionAttribute("1.0.0.0")]

// Generated by the MSBuild WriteCodeFragment class.


// <auto-generated/>
global using global::System;
global using global::System.Collections.Generic;
global using global::System.IO;
global using global::System.Linq;
global using global::System.Net.Http;
global using global::System.Threading;
global using global::System.Threading.Tasks;

using Domain.Models;
using Domain.Enums;
using Microsoft.EntityFrameworkCore;

namespace Infrastructure.DbContext
{
    public class AppDbContext : Microsoft.EntityFrameworkCore.DbContext
    {
        public AppDbContext(DbContextOptions<AppDbContext> options) : base(options) {}
        public DbSet<Client> Clients { get; set; }
        public DbSet<Account> Accounts { get; set; }
        public DbSet<AppUser> AppUsers { get; set; }
        public DbSet<Card> Cards { get; set; }
        public DbSet<Pan> Pans { get; set; }
        public DbSet<RefreshToken> RefreshTokens { get; set; }
        public DbSet<Transaction> Transactions { get; set; }

        protected override void OnModelCreating(ModelBuilder modelBuilder)
        {
            modelBuilder.Entity<AppUser>()
            .HasMany(a => a.refreshTokens)
            .WithOne(b => b.AppUser)
            .OnDelete(DeleteBehavior.Restrict);
            modelBuilder.Entity<Client>()
            .HasMany(b => b.AppUsers)
            .WithOne(a => a.Client)
            .OnDelete(DeleteBehavior.Restrict);
            modelBuilder.Entity<Client>()
            .HasMany(c => c.Accounts)
            .WithOne(a => a.Client)
            .HasForeignKey(a => a.ClientId)
            .OnDelete(DeleteBehavior.Restrict);
            modelBuilder.Entity<Account>()
            .HasMany(a => a.Cards)
            .WithOne(c => c.Account)
            .HasForeignKey(c => c.AccountId)
            .OnDelete(DeleteBehavior.Cascade);
            modelBuilder.Entity<Card>()
            .HasOne(c => c.Pan)
            .WithOne(p => p.Card)
            .HasForeignKey<Pan>(p => p.CardId)  
            .OnDelete(DeleteBehavior.Cascade);

            modelBuilder.Entity<Pan>()
            .HasOne(p => p.Card)
            .WithOne(c => c.Pan)
            .HasForeignKey<Pan>(p => p.CardId);

            modelBuilder.Entity<Client>()
            .HasMany(p => p.Transactions)
            .WithOne(c => c.Client)
            .OnDelete(DeleteBehavior.Restrict); 


        }
    }
}

using System;
using System.Collections.Generic;
using System.ComponentModel.Design;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using Infrastructure.DbContext;
using Microsoft.EntityFrameworkCore;
using Microsoft.EntityFrameworkCore.Design;
namespace Infrastructure
{
    public class AppDbContextFactory : IDesignTimeDbContextFactory<AppDbContext>
    {
        public AppDbContext CreateDbContext(string[] args)
        {
            var optionBuilder = new DbContextOptionsBuilder<AppDbContext>();
            optionBuilder.UseNpgsql("Host = localhost; Port = 5432; Database = BankSystem; Username = postgres; Password = 210624");
            return new AppDbContext(optionBuilder.Options);
        }
    }
}

using System.IdentityModel.Tokens;
using System.IdentityModel.Tokens.Jwt;
using System.Text;
using Application.Interfaces.Auth;
using Domain.Configuration;
using Domain.Models;
using Microsoft.Extensions.Options;
using Microsoft.IdentityModel.Tokens;
using System.Security.Claims;
using System.Security.Cryptography;

namespace Infrastructure.JWT
{
    public class JwtProvider : IJwtProvider
    {
        private readonly JwtOptions _options;
        public JwtProvider(IOptions<JwtOptions> options)
        {
            _options = options.Value;
        }
        public string GenerateRefreshToken()
        { 
            const int size = 32;

            byte[] bytes = new byte[size];

            using var rng = RandomNumberGenerator.Create(); 

            rng.GetBytes(bytes);

            using SHA256 sha256 = SHA256.Create();
            
            var key = sha256.ComputeHash(bytes);
            
            return Convert.ToBase64String(bytes);
        }
        public string GenerateToken(AppUser appUser)
        {
            Claim[] claims = new Claim[] 
            { 
                new Claim(JwtRegisteredClaimNames.Sub, appUser.Id.ToString()),
                new Claim(JwtRegisteredClaimNames.Jti, Guid.NewGuid().ToString()),
                new Claim(JwtRegisteredClaimNames.Iat, DateTimeOffset.UtcNow.ToUnixTimeSeconds().ToString(), ClaimValueTypes.Integer64)
            };

            var signingCredentials = new SigningCredentials
                (new SymmetricSecurityKey(Encoding.UTF8.GetBytes(_options.SecretKey)),
                SecurityAlgorithms.HmacSha256);

            var token = new JwtSecurityToken(
                    audience: _options.Audience,
                    issuer: _options.Issuer,
                    claims: claims,
                    signingCredentials: signingCredentials,
                    expires: DateTime.UtcNow.AddMinutes(_options.ExpireMinutes)
                );

            var tokenValue = new JwtSecurityTokenHandler().WriteToken(token);

            return tokenValue;
        }
    }
}

using System.Security.Cryptography;
using System.Text;
using System.Threading.Tasks;
using Application.Interfaces.Auth;
using Application.Interfaces.Repositories;
using Domain.Configuration;
using Domain.Models;
using Microsoft.AspNetCore.Http;
using Microsoft.Extensions.Configuration;
using Microsoft.Extensions.Options;
using UAParser;

namespace Infrastructure.JWT
{
    public class RefreshTokenProvider : IRefreshTokenProvider
    {
        private readonly IConfiguration _configuration;
        private readonly RefreshTokenOptions _options;
        private readonly IHttpContextAccessor _httpContextAccessor;
        private readonly IUserRepository _userRepository;
        private readonly IAppUserRepository _appUserRepository;
        public RefreshTokenProvider(IConfiguration configuration
            ,IOptions<RefreshTokenOptions> options
            ,IHttpContextAccessor httpContextAccessor
            ,IUserRepository userRepository
            ,IAppUserRepository appUserRepository)
        {
            _configuration = configuration;
            _options = options.Value;
            _httpContextAccessor = httpContextAccessor;
            _userRepository = userRepository;
            _appUserRepository = appUserRepository;
        }
        public async Task<RefreshToken> GenerateRefreshToken(Guid userId)
        {
            var refreshTokenValidityDays = _options.ExpireDays;

            var uaString = _httpContextAccessor.HttpContext?.Request.Headers["User-Agent"].ToString() ?? "Unknown";

            var parser = Parser.GetDefault();

            ClientInfo client = parser.Parse(uaString);

            var device_info = $"{client.UA.Family} on {client.OS.Family}";

            var appUser = await _appUserRepository.GetAppUserAsync(userId);

            var refreshToken = new RefreshToken
            {
                Id = Guid.NewGuid(),
                Token = Guid.NewGuid().ToString(),
                Expires = DateTime.UtcNow.AddDays(refreshTokenValidityDays),
                UserId = userId,
                AppUser = appUser,
                DeviceInfo = device_info
            };
            return refreshToken;
        }
        public string RefreshTokenHasher(string Token)
        {
            using SHA256 sha256 = SHA256.Create();

            var bytes = sha256.ComputeHash(Encoding.UTF8.GetBytes(Token));

            return Convert.ToBase64String(bytes);
        }
    }
}

using System;
using Microsoft.EntityFrameworkCore.Migrations;

#nullable disable

namespace Infrastructure.Migrations
{
    /// <inheritdoc />
    public partial class BankSystem : Migration
    {
        /// <inheritdoc />
        protected override void Up(MigrationBuilder migrationBuilder)
        {
            migrationBuilder.CreateTable(
                name: "Clients",
                columns: table => new
                {
                    Id = table.Column<Guid>(type: "uuid", nullable: false),
                    IIN = table.Column<string>(type: "text", nullable: false),
                    KycStatus = table.Column<int>(type: "integer", nullable: false),
                    FullName = table.Column<string>(type: "text", nullable: true),
                    IsDeleted = table.Column<bool>(type: "boolean", nullable: false),
                    PhoneNumber = table.Column<string>(type: "text", nullable: true)
                },
                constraints: table =>
                {
                    table.PrimaryKey("PK_Clients", x => x.Id);
                });

            migrationBuilder.CreateTable(
                name: "Accounts",
                columns: table => new
                {
                    Id = table.Column<Guid>(type: "uuid", nullable: false),
                    ClientId = table.Column<Guid>(type: "uuid", nullable: false),
                    Iban = table.Column<string>(type: "text", nullable: false),
                    Balance = table.Column<decimal>(type: "numeric", nullable: false)
                },
                constraints: table =>
                {
                    table.PrimaryKey("PK_Accounts", x => x.Id);
                    table.ForeignKey(
                        name: "FK_Accounts_Clients_ClientId",
                        column: x => x.ClientId,
                        principalTable: "Clients",
                        principalColumn: "Id",
                        onDelete: ReferentialAction.Restrict);
                });

            migrationBuilder.CreateTable(
                name: "AppUsers",
                columns: table => new
                {
                    Id = table.Column<Guid>(type: "uuid", nullable: false),
                    Email = table.Column<string>(type: "text", nullable: false),
                    PasswordHash = table.Column<string>(type: "text", nullable: false),
                    IsActive = table.Column<bool>(type: "boolean", nullable: false),
                    VerificationStatus = table.Column<int>(type: "integer", nullable: false),
                    ClientId = table.Column<Guid>(type: "uuid", nullable: false)
                },
                constraints: table =>
                {
                    table.PrimaryKey("PK_AppUsers", x => x.Id);
                    table.ForeignKey(
                        name: "FK_AppUsers_Clients_ClientId",
                        column: x => x.ClientId,
                        principalTable: "Clients",
                        principalColumn: "Id",
                        onDelete: ReferentialAction.Restrict);
                });

            migrationBuilder.CreateTable(
                name: "Cards",
                columns: table => new
                {
                    Id = table.Column<Guid>(type: "uuid", nullable: false),
                    AccountId = table.Column<Guid>(type: "uuid", nullable: false),
                    PanMasked = table.Column<string>(type: "text", nullable: true),
                    ExpiryDate = table.Column<string>(type: "text", nullable: true),
                    Status = table.Column<int>(type: "integer", nullable: true)
                },
                constraints: table =>
                {
                    table.PrimaryKey("PK_Cards", x => x.Id);
                    table.ForeignKey(
                        name: "FK_Cards_Accounts_AccountId",
                        column: x => x.AccountId,
                        principalTable: "Accounts",
                        principalColumn: "Id",
                        onDelete: ReferentialAction.Cascade);
                });

            migrationBuilder.CreateTable(
                name: "RefreshTokens",
                columns: table => new
                {
                    Id = table.Column<Guid>(type: "uuid", nullable: false),
                    Token = table.Column<string>(type: "text", nullable: false),
                    Expires = table.Column<DateTime>(type: "timestamp with time zone", nullable: false),
                    UserId = table.Column<Guid>(type: "uuid", nullable: false),
                    RevokedAt = table.Column<DateTime>(type: "timestamp with time zone", nullable: false),
                    DeviceInfo = table.Column<string>(type: "text", nullable: true),
                    AppUserId = table.Column<Guid>(type: "uuid", nullable: false)
                },
                constraints: table =>
                {
                    table.PrimaryKey("PK_RefreshTokens", x => x.Id);
                    table.ForeignKey(
                        name: "FK_RefreshTokens_AppUsers_AppUserId",
                        column: x => x.AppUserId,
                        principalTable: "AppUsers",
                        principalColumn: "Id",
                        onDelete: ReferentialAction.Restrict);
                });

            migrationBuilder.CreateTable(
                name: "Pans",
                columns: table => new
                {
                    Id = table.Column<Guid>(type: "uuid", nullable: false),
                    CardId = table.Column<Guid>(type: "uuid", nullable: false),
                    CipherText = table.Column<byte[]>(type: "bytea", nullable: false),
                    Nonce = table.Column<byte[]>(type: "bytea", nullable: false),
                    Tag = table.Column<byte[]>(type: "bytea", nullable: false)
                },
                constraints: table =>
                {
                    table.PrimaryKey("PK_Pans", x => x.Id);
                    table.ForeignKey(
                        name: "FK_Pans_Cards_CardId",
                        column: x => x.CardId,
                        principalTable: "Cards",
                        principalColumn: "Id",
                        onDelete: ReferentialAction.Cascade);
                });

            migrationBuilder.CreateIndex(
                name: "IX_Accounts_ClientId",
                table: "Accounts",
                column: "ClientId");

            migrationBuilder.CreateIndex(
                name: "IX_AppUsers_ClientId",
                table: "AppUsers",
                column: "ClientId");

            migrationBuilder.CreateIndex(
                name: "IX_Cards_AccountId",
                table: "Cards",
                column: "AccountId");

            migrationBuilder.CreateIndex(
                name: "IX_Pans_CardId",
                table: "Pans",
                column: "CardId",
                unique: true);

            migrationBuilder.CreateIndex(
                name: "IX_RefreshTokens_AppUserId",
                table: "RefreshTokens",
                column: "AppUserId");
        }

        /// <inheritdoc />
        protected override void Down(MigrationBuilder migrationBuilder)
        {
            migrationBuilder.DropTable(
                name: "Pans");

            migrationBuilder.DropTable(
                name: "RefreshTokens");

            migrationBuilder.DropTable(
                name: "Cards");

            migrationBuilder.DropTable(
                name: "AppUsers");

            migrationBuilder.DropTable(
                name: "Accounts");

            migrationBuilder.DropTable(
                name: "Clients");
        }
    }
}

// <auto-generated />
using System;
using Infrastructure.DbContext;
using Microsoft.EntityFrameworkCore;
using Microsoft.EntityFrameworkCore.Infrastructure;
using Microsoft.EntityFrameworkCore.Migrations;
using Microsoft.EntityFrameworkCore.Storage.ValueConversion;
using Npgsql.EntityFrameworkCore.PostgreSQL.Metadata;

#nullable disable

namespace Infrastructure.Migrations
{
    [DbContext(typeof(AppDbContext))]
    [Migration("20250927205142_BankSystem")]
    partial class BankSystem
    {
        /// <inheritdoc />
        protected override void BuildTargetModel(ModelBuilder modelBuilder)
        {
#pragma warning disable 612, 618
            modelBuilder
                .HasAnnotation("ProductVersion", "9.0.8")
                .HasAnnotation("Relational:MaxIdentifierLength", 63);

            NpgsqlModelBuilderExtensions.UseIdentityByDefaultColumns(modelBuilder);

            modelBuilder.Entity("Domain.Models.Account", b =>
                {
                    b.Property<Guid>("Id")
                        .ValueGeneratedOnAdd()
                        .HasColumnType("uuid");

                    b.Property<decimal>("Balance")
                        .HasColumnType("numeric");

                    b.Property<Guid>("ClientId")
                        .HasColumnType("uuid");

                    b.Property<string>("Iban")
                        .IsRequired()
                        .HasColumnType("text");

                    b.HasKey("Id");

                    b.HasIndex("ClientId");

                    b.ToTable("Accounts");
                });

            modelBuilder.Entity("Domain.Models.AppUser", b =>
                {
                    b.Property<Guid>("Id")
                        .ValueGeneratedOnAdd()
                        .HasColumnType("uuid");

                    b.Property<Guid>("ClientId")
                        .HasColumnType("uuid");

                    b.Property<string>("Email")
                        .IsRequired()
                        .HasColumnType("text");

                    b.Property<bool>("IsActive")
                        .HasColumnType("boolean");

                    b.Property<string>("PasswordHash")
                        .IsRequired()
                        .HasColumnType("text");

                    b.Property<int>("VerificationStatus")
                        .HasColumnType("integer");

                    b.HasKey("Id");

                    b.HasIndex("ClientId");

                    b.ToTable("AppUsers");
                });

            modelBuilder.Entity("Domain.Models.Card", b =>
                {
                    b.Property<Guid>("Id")
                        .ValueGeneratedOnAdd()
                        .HasColumnType("uuid");

                    b.Property<Guid>("AccountId")
                        .HasColumnType("uuid");

                    b.Property<string>("ExpiryDate")
                        .HasColumnType("text");

                    b.Property<string>("PanMasked")
                        .HasColumnType("text");

                    b.Property<int?>("Status")
                        .HasColumnType("integer");

                    b.HasKey("Id");

                    b.HasIndex("AccountId");

                    b.ToTable("Cards");
                });

            modelBuilder.Entity("Domain.Models.Client", b =>
                {
                    b.Property<Guid>("Id")
                        .ValueGeneratedOnAdd()
                        .HasColumnType("uuid");

                    b.Property<string>("FullName")
                        .HasColumnType("text");

                    b.Property<string>("IIN")
                        .IsRequired()
                        .HasColumnType("text");

                    b.Property<bool>("IsDeleted")
                        .HasColumnType("boolean");

                    b.Property<int>("KycStatus")
                        .HasColumnType("integer");

                    b.Property<string>("PhoneNumber")
                        .HasColumnType("text");

                    b.HasKey("Id");

                    b.ToTable("Clients");
                });

            modelBuilder.Entity("Domain.Models.Pan", b =>
                {
                    b.Property<Guid>("Id")
                        .ValueGeneratedOnAdd()
                        .HasColumnType("uuid");

                    b.Property<Guid>("CardId")
                        .HasColumnType("uuid");

                    b.Property<byte[]>("CipherText")
                        .IsRequired()
                        .HasColumnType("bytea");

                    b.Property<byte[]>("Nonce")
                        .IsRequired()
                        .HasColumnType("bytea");

                    b.Property<byte[]>("Tag")
                        .IsRequired()
                        .HasColumnType("bytea");

                    b.HasKey("Id");

                    b.HasIndex("CardId")
                        .IsUnique();

                    b.ToTable("Pans");
                });

            modelBuilder.Entity("Domain.Models.RefreshToken", b =>
                {
                    b.Property<Guid>("Id")
                        .ValueGeneratedOnAdd()
                        .HasColumnType("uuid");

                    b.Property<Guid>("AppUserId")
                        .HasColumnType("uuid");

                    b.Property<string>("DeviceInfo")
                        .HasColumnType("text");

                    b.Property<DateTime>("Expires")
                        .HasColumnType("timestamp with time zone");

                    b.Property<DateTime>("RevokedAt")
                        .HasColumnType("timestamp with time zone");

                    b.Property<string>("Token")
                        .IsRequired()
                        .HasColumnType("text");

                    b.Property<Guid>("UserId")
                        .HasColumnType("uuid");

                    b.HasKey("Id");

                    b.HasIndex("AppUserId");

                    b.ToTable("RefreshTokens");
                });

            modelBuilder.Entity("Domain.Models.Account", b =>
                {
                    b.HasOne("Domain.Models.Client", "Client")
                        .WithMany("Accounts")
                        .HasForeignKey("ClientId")
                        .OnDelete(DeleteBehavior.Restrict)
                        .IsRequired();

                    b.Navigation("Client");
                });

            modelBuilder.Entity("Domain.Models.AppUser", b =>
                {
                    b.HasOne("Domain.Models.Client", "Client")
                        .WithMany("AppUsers")
                        .HasForeignKey("ClientId")
                        .OnDelete(DeleteBehavior.Restrict)
                        .IsRequired();

                    b.Navigation("Client");
                });

            modelBuilder.Entity("Domain.Models.Card", b =>
                {
                    b.HasOne("Domain.Models.Account", "Account")
                        .WithMany("Cards")
                        .HasForeignKey("AccountId")
                        .OnDelete(DeleteBehavior.Cascade)
                        .IsRequired();

                    b.Navigation("Account");
                });

            modelBuilder.Entity("Domain.Models.Pan", b =>
                {
                    b.HasOne("Domain.Models.Card", "Card")
                        .WithOne("Pan")
                        .HasForeignKey("Domain.Models.Pan", "CardId")
                        .OnDelete(DeleteBehavior.Cascade)
                        .IsRequired();

                    b.Navigation("Card");
                });

            modelBuilder.Entity("Domain.Models.RefreshToken", b =>
                {
                    b.HasOne("Domain.Models.AppUser", "AppUser")
                        .WithMany("refreshTokens")
                        .HasForeignKey("AppUserId")
                        .OnDelete(DeleteBehavior.Restrict)
                        .IsRequired();

                    b.Navigation("AppUser");
                });

            modelBuilder.Entity("Domain.Models.Account", b =>
                {
                    b.Navigation("Cards");
                });

            modelBuilder.Entity("Domain.Models.AppUser", b =>
                {
                    b.Navigation("refreshTokens");
                });

            modelBuilder.Entity("Domain.Models.Card", b =>
                {
                    b.Navigation("Pan")
                        .IsRequired();
                });

            modelBuilder.Entity("Domain.Models.Client", b =>
                {
                    b.Navigation("Accounts");

                    b.Navigation("AppUsers");
                });
#pragma warning restore 612, 618
        }
    }
}

using System;
using Microsoft.EntityFrameworkCore.Migrations;

#nullable disable

namespace Infrastructure.Migrations
{
    /// <inheritdoc />
    public partial class AddedPincode : Migration
    {
        /// <inheritdoc />
        protected override void Up(MigrationBuilder migrationBuilder)
        {
            migrationBuilder.AddColumn<int>(
                name: "CountOfPinAttempts",
                table: "Cards",
                type: "integer",
                nullable: false,
                defaultValue: 0);

            migrationBuilder.AddColumn<string>(
                name: "PinCode",
                table: "Cards",
                type: "text",
                nullable: false,
                defaultValue: "");

            migrationBuilder.AddColumn<DateTime>(
                name: "BlockedUntil",
                table: "AppUsers",
                type: "timestamp with time zone",
                nullable: true);

            migrationBuilder.AddColumn<int>(
                name: "CountOfLoginAttempts",
                table: "AppUsers",
                type: "integer",
                nullable: false,
                defaultValue: 0);

            migrationBuilder.AddColumn<string>(
                name: "HashedPinCode",
                table: "AppUsers",
                type: "text",
                nullable: false,
                defaultValue: "");
        }

        /// <inheritdoc />
        protected override void Down(MigrationBuilder migrationBuilder)
        {
            migrationBuilder.DropColumn(
                name: "CountOfPinAttempts",
                table: "Cards");

            migrationBuilder.DropColumn(
                name: "PinCode",
                table: "Cards");

            migrationBuilder.DropColumn(
                name: "BlockedUntil",
                table: "AppUsers");

            migrationBuilder.DropColumn(
                name: "CountOfLoginAttempts",
                table: "AppUsers");

            migrationBuilder.DropColumn(
                name: "HashedPinCode",
                table: "AppUsers");
        }
    }
}

// <auto-generated />
using System;
using Infrastructure.DbContext;
using Microsoft.EntityFrameworkCore;
using Microsoft.EntityFrameworkCore.Infrastructure;
using Microsoft.EntityFrameworkCore.Migrations;
using Microsoft.EntityFrameworkCore.Storage.ValueConversion;
using Npgsql.EntityFrameworkCore.PostgreSQL.Metadata;

#nullable disable

namespace Infrastructure.Migrations
{
    [DbContext(typeof(AppDbContext))]
    [Migration("20250929080342_AddedPincode")]
    partial class AddedPincode
    {
        /// <inheritdoc />
        protected override void BuildTargetModel(ModelBuilder modelBuilder)
        {
#pragma warning disable 612, 618
            modelBuilder
                .HasAnnotation("ProductVersion", "9.0.8")
                .HasAnnotation("Relational:MaxIdentifierLength", 63);

            NpgsqlModelBuilderExtensions.UseIdentityByDefaultColumns(modelBuilder);

            modelBuilder.Entity("Domain.Models.Account", b =>
                {
                    b.Property<Guid>("Id")
                        .ValueGeneratedOnAdd()
                        .HasColumnType("uuid");

                    b.Property<decimal>("Balance")
                        .HasColumnType("numeric");

                    b.Property<Guid>("ClientId")
                        .HasColumnType("uuid");

                    b.Property<string>("Iban")
                        .IsRequired()
                        .HasColumnType("text");

                    b.HasKey("Id");

                    b.HasIndex("ClientId");

                    b.ToTable("Accounts");
                });

            modelBuilder.Entity("Domain.Models.AppUser", b =>
                {
                    b.Property<Guid>("Id")
                        .ValueGeneratedOnAdd()
                        .HasColumnType("uuid");

                    b.Property<DateTime?>("BlockedUntil")
                        .HasColumnType("timestamp with time zone");

                    b.Property<Guid>("ClientId")
                        .HasColumnType("uuid");

                    b.Property<int>("CountOfLoginAttempts")
                        .HasColumnType("integer");

                    b.Property<string>("Email")
                        .IsRequired()
                        .HasColumnType("text");

                    b.Property<string>("HashedPinCode")
                        .IsRequired()
                        .HasColumnType("text");

                    b.Property<bool>("IsActive")
                        .HasColumnType("boolean");

                    b.Property<string>("PasswordHash")
                        .IsRequired()
                        .HasColumnType("text");

                    b.Property<int>("VerificationStatus")
                        .HasColumnType("integer");

                    b.HasKey("Id");

                    b.HasIndex("ClientId");

                    b.ToTable("AppUsers");
                });

            modelBuilder.Entity("Domain.Models.Card", b =>
                {
                    b.Property<Guid>("Id")
                        .ValueGeneratedOnAdd()
                        .HasColumnType("uuid");

                    b.Property<Guid>("AccountId")
                        .HasColumnType("uuid");

                    b.Property<int>("CountOfPinAttempts")
                        .HasColumnType("integer");

                    b.Property<string>("ExpiryDate")
                        .HasColumnType("text");

                    b.Property<string>("PanMasked")
                        .HasColumnType("text");

                    b.Property<string>("PinCode")
                        .IsRequired()
                        .HasColumnType("text");

                    b.Property<int?>("Status")
                        .HasColumnType("integer");

                    b.HasKey("Id");

                    b.HasIndex("AccountId");

                    b.ToTable("Cards");
                });

            modelBuilder.Entity("Domain.Models.Client", b =>
                {
                    b.Property<Guid>("Id")
                        .ValueGeneratedOnAdd()
                        .HasColumnType("uuid");

                    b.Property<string>("FullName")
                        .HasColumnType("text");

                    b.Property<string>("IIN")
                        .IsRequired()
                        .HasColumnType("text");

                    b.Property<bool>("IsDeleted")
                        .HasColumnType("boolean");

                    b.Property<int>("KycStatus")
                        .HasColumnType("integer");

                    b.Property<string>("PhoneNumber")
                        .HasColumnType("text");

                    b.HasKey("Id");

                    b.ToTable("Clients");
                });

            modelBuilder.Entity("Domain.Models.Pan", b =>
                {
                    b.Property<Guid>("Id")
                        .ValueGeneratedOnAdd()
                        .HasColumnType("uuid");

                    b.Property<Guid>("CardId")
                        .HasColumnType("uuid");

                    b.Property<byte[]>("CipherText")
                        .IsRequired()
                        .HasColumnType("bytea");

                    b.Property<byte[]>("Nonce")
                        .IsRequired()
                        .HasColumnType("bytea");

                    b.Property<byte[]>("Tag")
                        .IsRequired()
                        .HasColumnType("bytea");

                    b.HasKey("Id");

                    b.HasIndex("CardId")
                        .IsUnique();

                    b.ToTable("Pans");
                });

            modelBuilder.Entity("Domain.Models.RefreshToken", b =>
                {
                    b.Property<Guid>("Id")
                        .ValueGeneratedOnAdd()
                        .HasColumnType("uuid");

                    b.Property<Guid>("AppUserId")
                        .HasColumnType("uuid");

                    b.Property<string>("DeviceInfo")
                        .HasColumnType("text");

                    b.Property<DateTime>("Expires")
                        .HasColumnType("timestamp with time zone");

                    b.Property<DateTime>("RevokedAt")
                        .HasColumnType("timestamp with time zone");

                    b.Property<string>("Token")
                        .IsRequired()
                        .HasColumnType("text");

                    b.Property<Guid>("UserId")
                        .HasColumnType("uuid");

                    b.HasKey("Id");

                    b.HasIndex("AppUserId");

                    b.ToTable("RefreshTokens");
                });

            modelBuilder.Entity("Domain.Models.Account", b =>
                {
                    b.HasOne("Domain.Models.Client", "Client")
                        .WithMany("Accounts")
                        .HasForeignKey("ClientId")
                        .OnDelete(DeleteBehavior.Restrict)
                        .IsRequired();

                    b.Navigation("Client");
                });

            modelBuilder.Entity("Domain.Models.AppUser", b =>
                {
                    b.HasOne("Domain.Models.Client", "Client")
                        .WithMany("AppUsers")
                        .HasForeignKey("ClientId")
                        .OnDelete(DeleteBehavior.Restrict)
                        .IsRequired();

                    b.Navigation("Client");
                });

            modelBuilder.Entity("Domain.Models.Card", b =>
                {
                    b.HasOne("Domain.Models.Account", "Account")
                        .WithMany("Cards")
                        .HasForeignKey("AccountId")
                        .OnDelete(DeleteBehavior.Cascade)
                        .IsRequired();

                    b.Navigation("Account");
                });

            modelBuilder.Entity("Domain.Models.Pan", b =>
                {
                    b.HasOne("Domain.Models.Card", "Card")
                        .WithOne("Pan")
                        .HasForeignKey("Domain.Models.Pan", "CardId")
                        .OnDelete(DeleteBehavior.Cascade)
                        .IsRequired();

                    b.Navigation("Card");
                });

            modelBuilder.Entity("Domain.Models.RefreshToken", b =>
                {
                    b.HasOne("Domain.Models.AppUser", "AppUser")
                        .WithMany("refreshTokens")
                        .HasForeignKey("AppUserId")
                        .OnDelete(DeleteBehavior.Restrict)
                        .IsRequired();

                    b.Navigation("AppUser");
                });

            modelBuilder.Entity("Domain.Models.Account", b =>
                {
                    b.Navigation("Cards");
                });

            modelBuilder.Entity("Domain.Models.AppUser", b =>
                {
                    b.Navigation("refreshTokens");
                });

            modelBuilder.Entity("Domain.Models.Card", b =>
                {
                    b.Navigation("Pan")
                        .IsRequired();
                });

            modelBuilder.Entity("Domain.Models.Client", b =>
                {
                    b.Navigation("Accounts");

                    b.Navigation("AppUsers");
                });
#pragma warning restore 612, 618
        }
    }
}

using Microsoft.EntityFrameworkCore.Migrations;

#nullable disable

namespace Infrastructure.Migrations
{
    /// <inheritdoc />
    public partial class FixedPin : Migration
    {
        /// <inheritdoc />
        protected override void Up(MigrationBuilder migrationBuilder)
        {
            migrationBuilder.AlterColumn<string>(
                name: "PinCode",
                table: "Cards",
                type: "text",
                nullable: true,
                oldClrType: typeof(string),
                oldType: "text");
        }

        /// <inheritdoc />
        protected override void Down(MigrationBuilder migrationBuilder)
        {
            migrationBuilder.AlterColumn<string>(
                name: "PinCode",
                table: "Cards",
                type: "text",
                nullable: false,
                defaultValue: "",
                oldClrType: typeof(string),
                oldType: "text",
                oldNullable: true);
        }
    }
}

// <auto-generated />
using System;
using Infrastructure.DbContext;
using Microsoft.EntityFrameworkCore;
using Microsoft.EntityFrameworkCore.Infrastructure;
using Microsoft.EntityFrameworkCore.Migrations;
using Microsoft.EntityFrameworkCore.Storage.ValueConversion;
using Npgsql.EntityFrameworkCore.PostgreSQL.Metadata;

#nullable disable

namespace Infrastructure.Migrations
{
    [DbContext(typeof(AppDbContext))]
    [Migration("20250929084748_FixedPin")]
    partial class FixedPin
    {
        /// <inheritdoc />
        protected override void BuildTargetModel(ModelBuilder modelBuilder)
        {
#pragma warning disable 612, 618
            modelBuilder
                .HasAnnotation("ProductVersion", "9.0.8")
                .HasAnnotation("Relational:MaxIdentifierLength", 63);

            NpgsqlModelBuilderExtensions.UseIdentityByDefaultColumns(modelBuilder);

            modelBuilder.Entity("Domain.Models.Account", b =>
                {
                    b.Property<Guid>("Id")
                        .ValueGeneratedOnAdd()
                        .HasColumnType("uuid");

                    b.Property<decimal>("Balance")
                        .HasColumnType("numeric");

                    b.Property<Guid>("ClientId")
                        .HasColumnType("uuid");

                    b.Property<string>("Iban")
                        .IsRequired()
                        .HasColumnType("text");

                    b.HasKey("Id");

                    b.HasIndex("ClientId");

                    b.ToTable("Accounts");
                });

            modelBuilder.Entity("Domain.Models.AppUser", b =>
                {
                    b.Property<Guid>("Id")
                        .ValueGeneratedOnAdd()
                        .HasColumnType("uuid");

                    b.Property<DateTime?>("BlockedUntil")
                        .HasColumnType("timestamp with time zone");

                    b.Property<Guid>("ClientId")
                        .HasColumnType("uuid");

                    b.Property<int>("CountOfLoginAttempts")
                        .HasColumnType("integer");

                    b.Property<string>("Email")
                        .IsRequired()
                        .HasColumnType("text");

                    b.Property<string>("HashedPinCode")
                        .IsRequired()
                        .HasColumnType("text");

                    b.Property<bool>("IsActive")
                        .HasColumnType("boolean");

                    b.Property<string>("PasswordHash")
                        .IsRequired()
                        .HasColumnType("text");

                    b.Property<int>("VerificationStatus")
                        .HasColumnType("integer");

                    b.HasKey("Id");

                    b.HasIndex("ClientId");

                    b.ToTable("AppUsers");
                });

            modelBuilder.Entity("Domain.Models.Card", b =>
                {
                    b.Property<Guid>("Id")
                        .ValueGeneratedOnAdd()
                        .HasColumnType("uuid");

                    b.Property<Guid>("AccountId")
                        .HasColumnType("uuid");

                    b.Property<int>("CountOfPinAttempts")
                        .HasColumnType("integer");

                    b.Property<string>("ExpiryDate")
                        .HasColumnType("text");

                    b.Property<string>("PanMasked")
                        .HasColumnType("text");

                    b.Property<string>("PinCode")
                        .HasColumnType("text");

                    b.Property<int?>("Status")
                        .HasColumnType("integer");

                    b.HasKey("Id");

                    b.HasIndex("AccountId");

                    b.ToTable("Cards");
                });

            modelBuilder.Entity("Domain.Models.Client", b =>
                {
                    b.Property<Guid>("Id")
                        .ValueGeneratedOnAdd()
                        .HasColumnType("uuid");

                    b.Property<string>("FullName")
                        .HasColumnType("text");

                    b.Property<string>("IIN")
                        .IsRequired()
                        .HasColumnType("text");

                    b.Property<bool>("IsDeleted")
                        .HasColumnType("boolean");

                    b.Property<int>("KycStatus")
                        .HasColumnType("integer");

                    b.Property<string>("PhoneNumber")
                        .HasColumnType("text");

                    b.HasKey("Id");

                    b.ToTable("Clients");
                });

            modelBuilder.Entity("Domain.Models.Pan", b =>
                {
                    b.Property<Guid>("Id")
                        .ValueGeneratedOnAdd()
                        .HasColumnType("uuid");

                    b.Property<Guid>("CardId")
                        .HasColumnType("uuid");

                    b.Property<byte[]>("CipherText")
                        .IsRequired()
                        .HasColumnType("bytea");

                    b.Property<byte[]>("Nonce")
                        .IsRequired()
                        .HasColumnType("bytea");

                    b.Property<byte[]>("Tag")
                        .IsRequired()
                        .HasColumnType("bytea");

                    b.HasKey("Id");

                    b.HasIndex("CardId")
                        .IsUnique();

                    b.ToTable("Pans");
                });

            modelBuilder.Entity("Domain.Models.RefreshToken", b =>
                {
                    b.Property<Guid>("Id")
                        .ValueGeneratedOnAdd()
                        .HasColumnType("uuid");

                    b.Property<Guid>("AppUserId")
                        .HasColumnType("uuid");

                    b.Property<string>("DeviceInfo")
                        .HasColumnType("text");

                    b.Property<DateTime>("Expires")
                        .HasColumnType("timestamp with time zone");

                    b.Property<DateTime>("RevokedAt")
                        .HasColumnType("timestamp with time zone");

                    b.Property<string>("Token")
                        .IsRequired()
                        .HasColumnType("text");

                    b.Property<Guid>("UserId")
                        .HasColumnType("uuid");

                    b.HasKey("Id");

                    b.HasIndex("AppUserId");

                    b.ToTable("RefreshTokens");
                });

            modelBuilder.Entity("Domain.Models.Account", b =>
                {
                    b.HasOne("Domain.Models.Client", "Client")
                        .WithMany("Accounts")
                        .HasForeignKey("ClientId")
                        .OnDelete(DeleteBehavior.Restrict)
                        .IsRequired();

                    b.Navigation("Client");
                });

            modelBuilder.Entity("Domain.Models.AppUser", b =>
                {
                    b.HasOne("Domain.Models.Client", "Client")
                        .WithMany("AppUsers")
                        .HasForeignKey("ClientId")
                        .OnDelete(DeleteBehavior.Restrict)
                        .IsRequired();

                    b.Navigation("Client");
                });

            modelBuilder.Entity("Domain.Models.Card", b =>
                {
                    b.HasOne("Domain.Models.Account", "Account")
                        .WithMany("Cards")
                        .HasForeignKey("AccountId")
                        .OnDelete(DeleteBehavior.Cascade)
                        .IsRequired();

                    b.Navigation("Account");
                });

            modelBuilder.Entity("Domain.Models.Pan", b =>
                {
                    b.HasOne("Domain.Models.Card", "Card")
                        .WithOne("Pan")
                        .HasForeignKey("Domain.Models.Pan", "CardId")
                        .OnDelete(DeleteBehavior.Cascade)
                        .IsRequired();

                    b.Navigation("Card");
                });

            modelBuilder.Entity("Domain.Models.RefreshToken", b =>
                {
                    b.HasOne("Domain.Models.AppUser", "AppUser")
                        .WithMany("refreshTokens")
                        .HasForeignKey("AppUserId")
                        .OnDelete(DeleteBehavior.Restrict)
                        .IsRequired();

                    b.Navigation("AppUser");
                });

            modelBuilder.Entity("Domain.Models.Account", b =>
                {
                    b.Navigation("Cards");
                });

            modelBuilder.Entity("Domain.Models.AppUser", b =>
                {
                    b.Navigation("refreshTokens");
                });

            modelBuilder.Entity("Domain.Models.Card", b =>
                {
                    b.Navigation("Pan")
                        .IsRequired();
                });

            modelBuilder.Entity("Domain.Models.Client", b =>
                {
                    b.Navigation("Accounts");

                    b.Navigation("AppUsers");
                });
#pragma warning restore 612, 618
        }
    }
}

using System;
using Microsoft.EntityFrameworkCore.Migrations;

#nullable disable

namespace Infrastructure.Migrations
{
    /// <inheritdoc />
    public partial class AddedPasswordLogin : Migration
    {
        /// <inheritdoc />
        protected override void Up(MigrationBuilder migrationBuilder)
        {
            migrationBuilder.AddColumn<DateTime>(
                name: "BlockedUntilPassword",
                table: "AppUsers",
                type: "timestamp with time zone",
                nullable: true);
        }

        /// <inheritdoc />
        protected override void Down(MigrationBuilder migrationBuilder)
        {
            migrationBuilder.DropColumn(
                name: "BlockedUntilPassword",
                table: "AppUsers");
        }
    }
}

// <auto-generated />
using System;
using Infrastructure.DbContext;
using Microsoft.EntityFrameworkCore;
using Microsoft.EntityFrameworkCore.Infrastructure;
using Microsoft.EntityFrameworkCore.Migrations;
using Microsoft.EntityFrameworkCore.Storage.ValueConversion;
using Npgsql.EntityFrameworkCore.PostgreSQL.Metadata;

#nullable disable

namespace Infrastructure.Migrations
{
    [DbContext(typeof(AppDbContext))]
    [Migration("20250929094537_AddedPasswordLogin")]
    partial class AddedPasswordLogin
    {
        /// <inheritdoc />
        protected override void BuildTargetModel(ModelBuilder modelBuilder)
        {
#pragma warning disable 612, 618
            modelBuilder
                .HasAnnotation("ProductVersion", "9.0.8")
                .HasAnnotation("Relational:MaxIdentifierLength", 63);

            NpgsqlModelBuilderExtensions.UseIdentityByDefaultColumns(modelBuilder);

            modelBuilder.Entity("Domain.Models.Account", b =>
                {
                    b.Property<Guid>("Id")
                        .ValueGeneratedOnAdd()
                        .HasColumnType("uuid");

                    b.Property<decimal>("Balance")
                        .HasColumnType("numeric");

                    b.Property<Guid>("ClientId")
                        .HasColumnType("uuid");

                    b.Property<string>("Iban")
                        .IsRequired()
                        .HasColumnType("text");

                    b.HasKey("Id");

                    b.HasIndex("ClientId");

                    b.ToTable("Accounts");
                });

            modelBuilder.Entity("Domain.Models.AppUser", b =>
                {
                    b.Property<Guid>("Id")
                        .ValueGeneratedOnAdd()
                        .HasColumnType("uuid");

                    b.Property<DateTime?>("BlockedUntil")
                        .HasColumnType("timestamp with time zone");

                    b.Property<DateTime?>("BlockedUntilPassword")
                        .HasColumnType("timestamp with time zone");

                    b.Property<Guid>("ClientId")
                        .HasColumnType("uuid");

                    b.Property<int>("CountOfLoginAttempts")
                        .HasColumnType("integer");

                    b.Property<string>("Email")
                        .IsRequired()
                        .HasColumnType("text");

                    b.Property<string>("HashedPinCode")
                        .IsRequired()
                        .HasColumnType("text");

                    b.Property<bool>("IsActive")
                        .HasColumnType("boolean");

                    b.Property<string>("PasswordHash")
                        .IsRequired()
                        .HasColumnType("text");

                    b.Property<int>("VerificationStatus")
                        .HasColumnType("integer");

                    b.HasKey("Id");

                    b.HasIndex("ClientId");

                    b.ToTable("AppUsers");
                });

            modelBuilder.Entity("Domain.Models.Card", b =>
                {
                    b.Property<Guid>("Id")
                        .ValueGeneratedOnAdd()
                        .HasColumnType("uuid");

                    b.Property<Guid>("AccountId")
                        .HasColumnType("uuid");

                    b.Property<int>("CountOfPinAttempts")
                        .HasColumnType("integer");

                    b.Property<string>("ExpiryDate")
                        .HasColumnType("text");

                    b.Property<string>("PanMasked")
                        .HasColumnType("text");

                    b.Property<string>("PinCode")
                        .HasColumnType("text");

                    b.Property<int?>("Status")
                        .HasColumnType("integer");

                    b.HasKey("Id");

                    b.HasIndex("AccountId");

                    b.ToTable("Cards");
                });

            modelBuilder.Entity("Domain.Models.Client", b =>
                {
                    b.Property<Guid>("Id")
                        .ValueGeneratedOnAdd()
                        .HasColumnType("uuid");

                    b.Property<string>("FullName")
                        .HasColumnType("text");

                    b.Property<string>("IIN")
                        .IsRequired()
                        .HasColumnType("text");

                    b.Property<bool>("IsDeleted")
                        .HasColumnType("boolean");

                    b.Property<int>("KycStatus")
                        .HasColumnType("integer");

                    b.Property<string>("PhoneNumber")
                        .HasColumnType("text");

                    b.HasKey("Id");

                    b.ToTable("Clients");
                });

            modelBuilder.Entity("Domain.Models.Pan", b =>
                {
                    b.Property<Guid>("Id")
                        .ValueGeneratedOnAdd()
                        .HasColumnType("uuid");

                    b.Property<Guid>("CardId")
                        .HasColumnType("uuid");

                    b.Property<byte[]>("CipherText")
                        .IsRequired()
                        .HasColumnType("bytea");

                    b.Property<byte[]>("Nonce")
                        .IsRequired()
                        .HasColumnType("bytea");

                    b.Property<byte[]>("Tag")
                        .IsRequired()
                        .HasColumnType("bytea");

                    b.HasKey("Id");

                    b.HasIndex("CardId")
                        .IsUnique();

                    b.ToTable("Pans");
                });

            modelBuilder.Entity("Domain.Models.RefreshToken", b =>
                {
                    b.Property<Guid>("Id")
                        .ValueGeneratedOnAdd()
                        .HasColumnType("uuid");

                    b.Property<Guid>("AppUserId")
                        .HasColumnType("uuid");

                    b.Property<string>("DeviceInfo")
                        .HasColumnType("text");

                    b.Property<DateTime>("Expires")
                        .HasColumnType("timestamp with time zone");

                    b.Property<DateTime>("RevokedAt")
                        .HasColumnType("timestamp with time zone");

                    b.Property<string>("Token")
                        .IsRequired()
                        .HasColumnType("text");

                    b.Property<Guid>("UserId")
                        .HasColumnType("uuid");

                    b.HasKey("Id");

                    b.HasIndex("AppUserId");

                    b.ToTable("RefreshTokens");
                });

            modelBuilder.Entity("Domain.Models.Account", b =>
                {
                    b.HasOne("Domain.Models.Client", "Client")
                        .WithMany("Accounts")
                        .HasForeignKey("ClientId")
                        .OnDelete(DeleteBehavior.Restrict)
                        .IsRequired();

                    b.Navigation("Client");
                });

            modelBuilder.Entity("Domain.Models.AppUser", b =>
                {
                    b.HasOne("Domain.Models.Client", "Client")
                        .WithMany("AppUsers")
                        .HasForeignKey("ClientId")
                        .OnDelete(DeleteBehavior.Restrict)
                        .IsRequired();

                    b.Navigation("Client");
                });

            modelBuilder.Entity("Domain.Models.Card", b =>
                {
                    b.HasOne("Domain.Models.Account", "Account")
                        .WithMany("Cards")
                        .HasForeignKey("AccountId")
                        .OnDelete(DeleteBehavior.Cascade)
                        .IsRequired();

                    b.Navigation("Account");
                });

            modelBuilder.Entity("Domain.Models.Pan", b =>
                {
                    b.HasOne("Domain.Models.Card", "Card")
                        .WithOne("Pan")
                        .HasForeignKey("Domain.Models.Pan", "CardId")
                        .OnDelete(DeleteBehavior.Cascade)
                        .IsRequired();

                    b.Navigation("Card");
                });

            modelBuilder.Entity("Domain.Models.RefreshToken", b =>
                {
                    b.HasOne("Domain.Models.AppUser", "AppUser")
                        .WithMany("refreshTokens")
                        .HasForeignKey("AppUserId")
                        .OnDelete(DeleteBehavior.Restrict)
                        .IsRequired();

                    b.Navigation("AppUser");
                });

            modelBuilder.Entity("Domain.Models.Account", b =>
                {
                    b.Navigation("Cards");
                });

            modelBuilder.Entity("Domain.Models.AppUser", b =>
                {
                    b.Navigation("refreshTokens");
                });

            modelBuilder.Entity("Domain.Models.Card", b =>
                {
                    b.Navigation("Pan")
                        .IsRequired();
                });

            modelBuilder.Entity("Domain.Models.Client", b =>
                {
                    b.Navigation("Accounts");

                    b.Navigation("AppUsers");
                });
#pragma warning restore 612, 618
        }
    }
}

using Microsoft.EntityFrameworkCore.Migrations;

#nullable disable

namespace Infrastructure.Migrations
{
    /// <inheritdoc />
    public partial class AddedPasswordLoginCounter : Migration
    {
        /// <inheritdoc />
        protected override void Up(MigrationBuilder migrationBuilder)
        {
            migrationBuilder.AddColumn<int>(
                name: "CountOfLoginViaPasswordAttempts",
                table: "AppUsers",
                type: "integer",
                nullable: false,
                defaultValue: 0);
        }

        /// <inheritdoc />
        protected override void Down(MigrationBuilder migrationBuilder)
        {
            migrationBuilder.DropColumn(
                name: "CountOfLoginViaPasswordAttempts",
                table: "AppUsers");
        }
    }
}

// <auto-generated />
using System;
using Infrastructure.DbContext;
using Microsoft.EntityFrameworkCore;
using Microsoft.EntityFrameworkCore.Infrastructure;
using Microsoft.EntityFrameworkCore.Migrations;
using Microsoft.EntityFrameworkCore.Storage.ValueConversion;
using Npgsql.EntityFrameworkCore.PostgreSQL.Metadata;

#nullable disable

namespace Infrastructure.Migrations
{
    [DbContext(typeof(AppDbContext))]
    [Migration("20250929113557_AddedPasswordLoginCounter")]
    partial class AddedPasswordLoginCounter
    {
        /// <inheritdoc />
        protected override void BuildTargetModel(ModelBuilder modelBuilder)
        {
#pragma warning disable 612, 618
            modelBuilder
                .HasAnnotation("ProductVersion", "9.0.8")
                .HasAnnotation("Relational:MaxIdentifierLength", 63);

            NpgsqlModelBuilderExtensions.UseIdentityByDefaultColumns(modelBuilder);

            modelBuilder.Entity("Domain.Models.Account", b =>
                {
                    b.Property<Guid>("Id")
                        .ValueGeneratedOnAdd()
                        .HasColumnType("uuid");

                    b.Property<decimal>("Balance")
                        .HasColumnType("numeric");

                    b.Property<Guid>("ClientId")
                        .HasColumnType("uuid");

                    b.Property<string>("Iban")
                        .IsRequired()
                        .HasColumnType("text");

                    b.HasKey("Id");

                    b.HasIndex("ClientId");

                    b.ToTable("Accounts");
                });

            modelBuilder.Entity("Domain.Models.AppUser", b =>
                {
                    b.Property<Guid>("Id")
                        .ValueGeneratedOnAdd()
                        .HasColumnType("uuid");

                    b.Property<DateTime?>("BlockedUntil")
                        .HasColumnType("timestamp with time zone");

                    b.Property<DateTime?>("BlockedUntilPassword")
                        .HasColumnType("timestamp with time zone");

                    b.Property<Guid>("ClientId")
                        .HasColumnType("uuid");

                    b.Property<int>("CountOfLoginAttempts")
                        .HasColumnType("integer");

                    b.Property<int>("CountOfLoginViaPasswordAttempts")
                        .HasColumnType("integer");

                    b.Property<string>("Email")
                        .IsRequired()
                        .HasColumnType("text");

                    b.Property<string>("HashedPinCode")
                        .IsRequired()
                        .HasColumnType("text");

                    b.Property<bool>("IsActive")
                        .HasColumnType("boolean");

                    b.Property<string>("PasswordHash")
                        .IsRequired()
                        .HasColumnType("text");

                    b.Property<int>("VerificationStatus")
                        .HasColumnType("integer");

                    b.HasKey("Id");

                    b.HasIndex("ClientId");

                    b.ToTable("AppUsers");
                });

            modelBuilder.Entity("Domain.Models.Card", b =>
                {
                    b.Property<Guid>("Id")
                        .ValueGeneratedOnAdd()
                        .HasColumnType("uuid");

                    b.Property<Guid>("AccountId")
                        .HasColumnType("uuid");

                    b.Property<int>("CountOfPinAttempts")
                        .HasColumnType("integer");

                    b.Property<string>("ExpiryDate")
                        .HasColumnType("text");

                    b.Property<string>("PanMasked")
                        .HasColumnType("text");

                    b.Property<string>("PinCode")
                        .HasColumnType("text");

                    b.Property<int?>("Status")
                        .HasColumnType("integer");

                    b.HasKey("Id");

                    b.HasIndex("AccountId");

                    b.ToTable("Cards");
                });

            modelBuilder.Entity("Domain.Models.Client", b =>
                {
                    b.Property<Guid>("Id")
                        .ValueGeneratedOnAdd()
                        .HasColumnType("uuid");

                    b.Property<string>("FullName")
                        .HasColumnType("text");

                    b.Property<string>("IIN")
                        .IsRequired()
                        .HasColumnType("text");

                    b.Property<bool>("IsDeleted")
                        .HasColumnType("boolean");

                    b.Property<int>("KycStatus")
                        .HasColumnType("integer");

                    b.Property<string>("PhoneNumber")
                        .HasColumnType("text");

                    b.HasKey("Id");

                    b.ToTable("Clients");
                });

            modelBuilder.Entity("Domain.Models.Pan", b =>
                {
                    b.Property<Guid>("Id")
                        .ValueGeneratedOnAdd()
                        .HasColumnType("uuid");

                    b.Property<Guid>("CardId")
                        .HasColumnType("uuid");

                    b.Property<byte[]>("CipherText")
                        .IsRequired()
                        .HasColumnType("bytea");

                    b.Property<byte[]>("Nonce")
                        .IsRequired()
                        .HasColumnType("bytea");

                    b.Property<byte[]>("Tag")
                        .IsRequired()
                        .HasColumnType("bytea");

                    b.HasKey("Id");

                    b.HasIndex("CardId")
                        .IsUnique();

                    b.ToTable("Pans");
                });

            modelBuilder.Entity("Domain.Models.RefreshToken", b =>
                {
                    b.Property<Guid>("Id")
                        .ValueGeneratedOnAdd()
                        .HasColumnType("uuid");

                    b.Property<Guid>("AppUserId")
                        .HasColumnType("uuid");

                    b.Property<string>("DeviceInfo")
                        .HasColumnType("text");

                    b.Property<DateTime>("Expires")
                        .HasColumnType("timestamp with time zone");

                    b.Property<DateTime>("RevokedAt")
                        .HasColumnType("timestamp with time zone");

                    b.Property<string>("Token")
                        .IsRequired()
                        .HasColumnType("text");

                    b.Property<Guid>("UserId")
                        .HasColumnType("uuid");

                    b.HasKey("Id");

                    b.HasIndex("AppUserId");

                    b.ToTable("RefreshTokens");
                });

            modelBuilder.Entity("Domain.Models.Account", b =>
                {
                    b.HasOne("Domain.Models.Client", "Client")
                        .WithMany("Accounts")
                        .HasForeignKey("ClientId")
                        .OnDelete(DeleteBehavior.Restrict)
                        .IsRequired();

                    b.Navigation("Client");
                });

            modelBuilder.Entity("Domain.Models.AppUser", b =>
                {
                    b.HasOne("Domain.Models.Client", "Client")
                        .WithMany("AppUsers")
                        .HasForeignKey("ClientId")
                        .OnDelete(DeleteBehavior.Restrict)
                        .IsRequired();

                    b.Navigation("Client");
                });

            modelBuilder.Entity("Domain.Models.Card", b =>
                {
                    b.HasOne("Domain.Models.Account", "Account")
                        .WithMany("Cards")
                        .HasForeignKey("AccountId")
                        .OnDelete(DeleteBehavior.Cascade)
                        .IsRequired();

                    b.Navigation("Account");
                });

            modelBuilder.Entity("Domain.Models.Pan", b =>
                {
                    b.HasOne("Domain.Models.Card", "Card")
                        .WithOne("Pan")
                        .HasForeignKey("Domain.Models.Pan", "CardId")
                        .OnDelete(DeleteBehavior.Cascade)
                        .IsRequired();

                    b.Navigation("Card");
                });

            modelBuilder.Entity("Domain.Models.RefreshToken", b =>
                {
                    b.HasOne("Domain.Models.AppUser", "AppUser")
                        .WithMany("refreshTokens")
                        .HasForeignKey("AppUserId")
                        .OnDelete(DeleteBehavior.Restrict)
                        .IsRequired();

                    b.Navigation("AppUser");
                });

            modelBuilder.Entity("Domain.Models.Account", b =>
                {
                    b.Navigation("Cards");
                });

            modelBuilder.Entity("Domain.Models.AppUser", b =>
                {
                    b.Navigation("refreshTokens");
                });

            modelBuilder.Entity("Domain.Models.Card", b =>
                {
                    b.Navigation("Pan")
                        .IsRequired();
                });

            modelBuilder.Entity("Domain.Models.Client", b =>
                {
                    b.Navigation("Accounts");

                    b.Navigation("AppUsers");
                });
#pragma warning restore 612, 618
        }
    }
}

using System;
using Microsoft.EntityFrameworkCore.Migrations;

#nullable disable

namespace Infrastructure.Migrations
{
    /// <inheritdoc />
    public partial class AddedTransactions : Migration
    {
        /// <inheritdoc />
        protected override void Up(MigrationBuilder migrationBuilder)
        {
            migrationBuilder.AddColumn<decimal>(
                name: "DepositedLastDay",
                table: "Accounts",
                type: "numeric",
                nullable: true);

            migrationBuilder.AddColumn<DateOnly>(
                name: "LastDepositDateKz",
                table: "Accounts",
                type: "date",
                nullable: false,
                defaultValue: new DateOnly(1, 1, 1));

            migrationBuilder.CreateTable(
                name: "Transactions",
                columns: table => new
                {
                    Id = table.Column<Guid>(type: "uuid", nullable: false),
                    From = table.Column<string>(type: "text", nullable: false),
                    To = table.Column<string>(type: "text", nullable: false),
                    ClientId = table.Column<Guid>(type: "uuid", nullable: false),
                    Amount = table.Column<decimal>(type: "numeric", nullable: false),
                    CreatedAt = table.Column<DateTime>(type: "timestamp with time zone", nullable: false),
                    Type = table.Column<string>(type: "text", nullable: false)
                },
                constraints: table =>
                {
                    table.PrimaryKey("PK_Transactions", x => x.Id);
                    table.ForeignKey(
                        name: "FK_Transactions_Clients_ClientId",
                        column: x => x.ClientId,
                        principalTable: "Clients",
                        principalColumn: "Id",
                        onDelete: ReferentialAction.Restrict);
                });

            migrationBuilder.CreateIndex(
                name: "IX_Transactions_ClientId",
                table: "Transactions",
                column: "ClientId");
        }

        /// <inheritdoc />
        protected override void Down(MigrationBuilder migrationBuilder)
        {
            migrationBuilder.DropTable(
                name: "Transactions");

            migrationBuilder.DropColumn(
                name: "DepositedLastDay",
                table: "Accounts");

            migrationBuilder.DropColumn(
                name: "LastDepositDateKz",
                table: "Accounts");
        }
    }
}

// <auto-generated />
using System;
using Infrastructure.DbContext;
using Microsoft.EntityFrameworkCore;
using Microsoft.EntityFrameworkCore.Infrastructure;
using Microsoft.EntityFrameworkCore.Migrations;
using Microsoft.EntityFrameworkCore.Storage.ValueConversion;
using Npgsql.EntityFrameworkCore.PostgreSQL.Metadata;

#nullable disable

namespace Infrastructure.Migrations
{
    [DbContext(typeof(AppDbContext))]
    [Migration("20250929184020_AddedTransactions")]
    partial class AddedTransactions
    {
        /// <inheritdoc />
        protected override void BuildTargetModel(ModelBuilder modelBuilder)
        {
#pragma warning disable 612, 618
            modelBuilder
                .HasAnnotation("ProductVersion", "9.0.9")
                .HasAnnotation("Relational:MaxIdentifierLength", 63);

            NpgsqlModelBuilderExtensions.UseIdentityByDefaultColumns(modelBuilder);

            modelBuilder.Entity("Domain.Models.Account", b =>
                {
                    b.Property<Guid>("Id")
                        .ValueGeneratedOnAdd()
                        .HasColumnType("uuid");

                    b.Property<decimal>("Balance")
                        .HasColumnType("numeric");

                    b.Property<Guid>("ClientId")
                        .HasColumnType("uuid");

                    b.Property<decimal?>("DepositedLastDay")
                        .HasColumnType("numeric");

                    b.Property<string>("Iban")
                        .IsRequired()
                        .HasColumnType("text");

                    b.Property<DateOnly>("LastDepositDateKz")
                        .HasColumnType("date");

                    b.HasKey("Id");

                    b.HasIndex("ClientId");

                    b.ToTable("Accounts");
                });

            modelBuilder.Entity("Domain.Models.AppUser", b =>
                {
                    b.Property<Guid>("Id")
                        .ValueGeneratedOnAdd()
                        .HasColumnType("uuid");

                    b.Property<DateTime?>("BlockedUntil")
                        .HasColumnType("timestamp with time zone");

                    b.Property<DateTime?>("BlockedUntilPassword")
                        .HasColumnType("timestamp with time zone");

                    b.Property<Guid>("ClientId")
                        .HasColumnType("uuid");

                    b.Property<int>("CountOfLoginAttempts")
                        .HasColumnType("integer");

                    b.Property<int>("CountOfLoginViaPasswordAttempts")
                        .HasColumnType("integer");

                    b.Property<string>("Email")
                        .IsRequired()
                        .HasColumnType("text");

                    b.Property<string>("HashedPinCode")
                        .IsRequired()
                        .HasColumnType("text");

                    b.Property<bool>("IsActive")
                        .HasColumnType("boolean");

                    b.Property<string>("PasswordHash")
                        .IsRequired()
                        .HasColumnType("text");

                    b.Property<int>("VerificationStatus")
                        .HasColumnType("integer");

                    b.HasKey("Id");

                    b.HasIndex("ClientId");

                    b.ToTable("AppUsers");
                });

            modelBuilder.Entity("Domain.Models.Card", b =>
                {
                    b.Property<Guid>("Id")
                        .ValueGeneratedOnAdd()
                        .HasColumnType("uuid");

                    b.Property<Guid>("AccountId")
                        .HasColumnType("uuid");

                    b.Property<int>("CountOfPinAttempts")
                        .HasColumnType("integer");

                    b.Property<string>("ExpiryDate")
                        .HasColumnType("text");

                    b.Property<string>("PanMasked")
                        .HasColumnType("text");

                    b.Property<string>("PinCode")
                        .HasColumnType("text");

                    b.Property<int?>("Status")
                        .HasColumnType("integer");

                    b.HasKey("Id");

                    b.HasIndex("AccountId");

                    b.ToTable("Cards");
                });

            modelBuilder.Entity("Domain.Models.Client", b =>
                {
                    b.Property<Guid>("Id")
                        .ValueGeneratedOnAdd()
                        .HasColumnType("uuid");

                    b.Property<string>("FullName")
                        .HasColumnType("text");

                    b.Property<string>("IIN")
                        .IsRequired()
                        .HasColumnType("text");

                    b.Property<bool>("IsDeleted")
                        .HasColumnType("boolean");

                    b.Property<int>("KycStatus")
                        .HasColumnType("integer");

                    b.Property<string>("PhoneNumber")
                        .HasColumnType("text");

                    b.HasKey("Id");

                    b.ToTable("Clients");
                });

            modelBuilder.Entity("Domain.Models.Pan", b =>
                {
                    b.Property<Guid>("Id")
                        .ValueGeneratedOnAdd()
                        .HasColumnType("uuid");

                    b.Property<Guid>("CardId")
                        .HasColumnType("uuid");

                    b.Property<byte[]>("CipherText")
                        .IsRequired()
                        .HasColumnType("bytea");

                    b.Property<byte[]>("Nonce")
                        .IsRequired()
                        .HasColumnType("bytea");

                    b.Property<byte[]>("Tag")
                        .IsRequired()
                        .HasColumnType("bytea");

                    b.HasKey("Id");

                    b.HasIndex("CardId")
                        .IsUnique();

                    b.ToTable("Pans");
                });

            modelBuilder.Entity("Domain.Models.RefreshToken", b =>
                {
                    b.Property<Guid>("Id")
                        .ValueGeneratedOnAdd()
                        .HasColumnType("uuid");

                    b.Property<Guid>("AppUserId")
                        .HasColumnType("uuid");

                    b.Property<string>("DeviceInfo")
                        .HasColumnType("text");

                    b.Property<DateTime>("Expires")
                        .HasColumnType("timestamp with time zone");

                    b.Property<DateTime>("RevokedAt")
                        .HasColumnType("timestamp with time zone");

                    b.Property<string>("Token")
                        .IsRequired()
                        .HasColumnType("text");

                    b.Property<Guid>("UserId")
                        .HasColumnType("uuid");

                    b.HasKey("Id");

                    b.HasIndex("AppUserId");

                    b.ToTable("RefreshTokens");
                });

            modelBuilder.Entity("Domain.Models.Transaction", b =>
                {
                    b.Property<Guid>("Id")
                        .ValueGeneratedOnAdd()
                        .HasColumnType("uuid");

                    b.Property<decimal>("Amount")
                        .HasColumnType("numeric");

                    b.Property<Guid>("ClientId")
                        .HasColumnType("uuid");

                    b.Property<DateTime>("CreatedAt")
                        .HasColumnType("timestamp with time zone");

                    b.Property<string>("From")
                        .IsRequired()
                        .HasColumnType("text");

                    b.Property<string>("To")
                        .IsRequired()
                        .HasColumnType("text");

                    b.Property<string>("Type")
                        .IsRequired()
                        .HasColumnType("text");

                    b.HasKey("Id");

                    b.HasIndex("ClientId");

                    b.ToTable("Transactions");
                });

            modelBuilder.Entity("Domain.Models.Account", b =>
                {
                    b.HasOne("Domain.Models.Client", "Client")
                        .WithMany("Accounts")
                        .HasForeignKey("ClientId")
                        .OnDelete(DeleteBehavior.Restrict)
                        .IsRequired();

                    b.Navigation("Client");
                });

            modelBuilder.Entity("Domain.Models.AppUser", b =>
                {
                    b.HasOne("Domain.Models.Client", "Client")
                        .WithMany("AppUsers")
                        .HasForeignKey("ClientId")
                        .OnDelete(DeleteBehavior.Restrict)
                        .IsRequired();

                    b.Navigation("Client");
                });

            modelBuilder.Entity("Domain.Models.Card", b =>
                {
                    b.HasOne("Domain.Models.Account", "Account")
                        .WithMany("Cards")
                        .HasForeignKey("AccountId")
                        .OnDelete(DeleteBehavior.Cascade)
                        .IsRequired();

                    b.Navigation("Account");
                });

            modelBuilder.Entity("Domain.Models.Pan", b =>
                {
                    b.HasOne("Domain.Models.Card", "Card")
                        .WithOne("Pan")
                        .HasForeignKey("Domain.Models.Pan", "CardId")
                        .OnDelete(DeleteBehavior.Cascade)
                        .IsRequired();

                    b.Navigation("Card");
                });

            modelBuilder.Entity("Domain.Models.RefreshToken", b =>
                {
                    b.HasOne("Domain.Models.AppUser", "AppUser")
                        .WithMany("refreshTokens")
                        .HasForeignKey("AppUserId")
                        .OnDelete(DeleteBehavior.Restrict)
                        .IsRequired();

                    b.Navigation("AppUser");
                });

            modelBuilder.Entity("Domain.Models.Transaction", b =>
                {
                    b.HasOne("Domain.Models.Client", "Client")
                        .WithMany("Transactions")
                        .HasForeignKey("ClientId")
                        .OnDelete(DeleteBehavior.Restrict)
                        .IsRequired();

                    b.Navigation("Client");
                });

            modelBuilder.Entity("Domain.Models.Account", b =>
                {
                    b.Navigation("Cards");
                });

            modelBuilder.Entity("Domain.Models.AppUser", b =>
                {
                    b.Navigation("refreshTokens");
                });

            modelBuilder.Entity("Domain.Models.Card", b =>
                {
                    b.Navigation("Pan")
                        .IsRequired();
                });

            modelBuilder.Entity("Domain.Models.Client", b =>
                {
                    b.Navigation("Accounts");

                    b.Navigation("AppUsers");

                    b.Navigation("Transactions");
                });
#pragma warning restore 612, 618
        }
    }
}

using System;
using Microsoft.EntityFrameworkCore.Migrations;

#nullable disable

namespace Infrastructure.Migrations
{
    /// <inheritdoc />
    public partial class AddedTransfering : Migration
    {
        /// <inheritdoc />
        protected override void Up(MigrationBuilder migrationBuilder)
        {
            migrationBuilder.AddColumn<DateOnly>(
                name: "LastTransferDateKz",
                table: "Accounts",
                type: "date",
                nullable: false,
                defaultValue: new DateOnly(1, 1, 1));

            migrationBuilder.AddColumn<decimal>(
                name: "TransferredLastDay",
                table: "Accounts",
                type: "numeric",
                nullable: true);
        }

        /// <inheritdoc />
        protected override void Down(MigrationBuilder migrationBuilder)
        {
            migrationBuilder.DropColumn(
                name: "LastTransferDateKz",
                table: "Accounts");

            migrationBuilder.DropColumn(
                name: "TransferredLastDay",
                table: "Accounts");
        }
    }
}

// <auto-generated />
using System;
using Infrastructure.DbContext;
using Microsoft.EntityFrameworkCore;
using Microsoft.EntityFrameworkCore.Infrastructure;
using Microsoft.EntityFrameworkCore.Migrations;
using Microsoft.EntityFrameworkCore.Storage.ValueConversion;
using Npgsql.EntityFrameworkCore.PostgreSQL.Metadata;

#nullable disable

namespace Infrastructure.Migrations
{
    [DbContext(typeof(AppDbContext))]
    [Migration("20250929212050_AddedTransfering")]
    partial class AddedTransfering
    {
        /// <inheritdoc />
        protected override void BuildTargetModel(ModelBuilder modelBuilder)
        {
#pragma warning disable 612, 618
            modelBuilder
                .HasAnnotation("ProductVersion", "9.0.9")
                .HasAnnotation("Relational:MaxIdentifierLength", 63);

            NpgsqlModelBuilderExtensions.UseIdentityByDefaultColumns(modelBuilder);

            modelBuilder.Entity("Domain.Models.Account", b =>
                {
                    b.Property<Guid>("Id")
                        .ValueGeneratedOnAdd()
                        .HasColumnType("uuid");

                    b.Property<decimal>("Balance")
                        .HasColumnType("numeric");

                    b.Property<Guid>("ClientId")
                        .HasColumnType("uuid");

                    b.Property<decimal?>("DepositedLastDay")
                        .HasColumnType("numeric");

                    b.Property<string>("Iban")
                        .IsRequired()
                        .HasColumnType("text");

                    b.Property<DateOnly>("LastDepositDateKz")
                        .HasColumnType("date");

                    b.Property<DateOnly>("LastTransferDateKz")
                        .HasColumnType("date");

                    b.Property<decimal?>("TransferredLastDay")
                        .HasColumnType("numeric");

                    b.HasKey("Id");

                    b.HasIndex("ClientId");

                    b.ToTable("Accounts");
                });

            modelBuilder.Entity("Domain.Models.AppUser", b =>
                {
                    b.Property<Guid>("Id")
                        .ValueGeneratedOnAdd()
                        .HasColumnType("uuid");

                    b.Property<DateTime?>("BlockedUntil")
                        .HasColumnType("timestamp with time zone");

                    b.Property<DateTime?>("BlockedUntilPassword")
                        .HasColumnType("timestamp with time zone");

                    b.Property<Guid>("ClientId")
                        .HasColumnType("uuid");

                    b.Property<int>("CountOfLoginAttempts")
                        .HasColumnType("integer");

                    b.Property<int>("CountOfLoginViaPasswordAttempts")
                        .HasColumnType("integer");

                    b.Property<string>("Email")
                        .IsRequired()
                        .HasColumnType("text");

                    b.Property<string>("HashedPinCode")
                        .IsRequired()
                        .HasColumnType("text");

                    b.Property<bool>("IsActive")
                        .HasColumnType("boolean");

                    b.Property<string>("PasswordHash")
                        .IsRequired()
                        .HasColumnType("text");

                    b.Property<int>("VerificationStatus")
                        .HasColumnType("integer");

                    b.HasKey("Id");

                    b.HasIndex("ClientId");

                    b.ToTable("AppUsers");
                });

            modelBuilder.Entity("Domain.Models.Card", b =>
                {
                    b.Property<Guid>("Id")
                        .ValueGeneratedOnAdd()
                        .HasColumnType("uuid");

                    b.Property<Guid>("AccountId")
                        .HasColumnType("uuid");

                    b.Property<int>("CountOfPinAttempts")
                        .HasColumnType("integer");

                    b.Property<string>("ExpiryDate")
                        .HasColumnType("text");

                    b.Property<string>("PanMasked")
                        .HasColumnType("text");

                    b.Property<string>("PinCode")
                        .HasColumnType("text");

                    b.Property<int?>("Status")
                        .HasColumnType("integer");

                    b.HasKey("Id");

                    b.HasIndex("AccountId");

                    b.ToTable("Cards");
                });

            modelBuilder.Entity("Domain.Models.Client", b =>
                {
                    b.Property<Guid>("Id")
                        .ValueGeneratedOnAdd()
                        .HasColumnType("uuid");

                    b.Property<string>("FullName")
                        .HasColumnType("text");

                    b.Property<string>("IIN")
                        .IsRequired()
                        .HasColumnType("text");

                    b.Property<bool>("IsDeleted")
                        .HasColumnType("boolean");

                    b.Property<int>("KycStatus")
                        .HasColumnType("integer");

                    b.Property<string>("PhoneNumber")
                        .HasColumnType("text");

                    b.HasKey("Id");

                    b.ToTable("Clients");
                });

            modelBuilder.Entity("Domain.Models.Pan", b =>
                {
                    b.Property<Guid>("Id")
                        .ValueGeneratedOnAdd()
                        .HasColumnType("uuid");

                    b.Property<Guid>("CardId")
                        .HasColumnType("uuid");

                    b.Property<byte[]>("CipherText")
                        .IsRequired()
                        .HasColumnType("bytea");

                    b.Property<byte[]>("Nonce")
                        .IsRequired()
                        .HasColumnType("bytea");

                    b.Property<byte[]>("Tag")
                        .IsRequired()
                        .HasColumnType("bytea");

                    b.HasKey("Id");

                    b.HasIndex("CardId")
                        .IsUnique();

                    b.ToTable("Pans");
                });

            modelBuilder.Entity("Domain.Models.RefreshToken", b =>
                {
                    b.Property<Guid>("Id")
                        .ValueGeneratedOnAdd()
                        .HasColumnType("uuid");

                    b.Property<Guid>("AppUserId")
                        .HasColumnType("uuid");

                    b.Property<string>("DeviceInfo")
                        .HasColumnType("text");

                    b.Property<DateTime>("Expires")
                        .HasColumnType("timestamp with time zone");

                    b.Property<DateTime>("RevokedAt")
                        .HasColumnType("timestamp with time zone");

                    b.Property<string>("Token")
                        .IsRequired()
                        .HasColumnType("text");

                    b.Property<Guid>("UserId")
                        .HasColumnType("uuid");

                    b.HasKey("Id");

                    b.HasIndex("AppUserId");

                    b.ToTable("RefreshTokens");
                });

            modelBuilder.Entity("Domain.Models.Transaction", b =>
                {
                    b.Property<Guid>("Id")
                        .ValueGeneratedOnAdd()
                        .HasColumnType("uuid");

                    b.Property<decimal>("Amount")
                        .HasColumnType("numeric");

                    b.Property<Guid>("ClientId")
                        .HasColumnType("uuid");

                    b.Property<DateTime>("CreatedAt")
                        .HasColumnType("timestamp with time zone");

                    b.Property<string>("From")
                        .IsRequired()
                        .HasColumnType("text");

                    b.Property<string>("To")
                        .IsRequired()
                        .HasColumnType("text");

                    b.Property<string>("Type")
                        .IsRequired()
                        .HasColumnType("text");

                    b.HasKey("Id");

                    b.HasIndex("ClientId");

                    b.ToTable("Transactions");
                });

            modelBuilder.Entity("Domain.Models.Account", b =>
                {
                    b.HasOne("Domain.Models.Client", "Client")
                        .WithMany("Accounts")
                        .HasForeignKey("ClientId")
                        .OnDelete(DeleteBehavior.Restrict)
                        .IsRequired();

                    b.Navigation("Client");
                });

            modelBuilder.Entity("Domain.Models.AppUser", b =>
                {
                    b.HasOne("Domain.Models.Client", "Client")
                        .WithMany("AppUsers")
                        .HasForeignKey("ClientId")
                        .OnDelete(DeleteBehavior.Restrict)
                        .IsRequired();

                    b.Navigation("Client");
                });

            modelBuilder.Entity("Domain.Models.Card", b =>
                {
                    b.HasOne("Domain.Models.Account", "Account")
                        .WithMany("Cards")
                        .HasForeignKey("AccountId")
                        .OnDelete(DeleteBehavior.Cascade)
                        .IsRequired();

                    b.Navigation("Account");
                });

            modelBuilder.Entity("Domain.Models.Pan", b =>
                {
                    b.HasOne("Domain.Models.Card", "Card")
                        .WithOne("Pan")
                        .HasForeignKey("Domain.Models.Pan", "CardId")
                        .OnDelete(DeleteBehavior.Cascade)
                        .IsRequired();

                    b.Navigation("Card");
                });

            modelBuilder.Entity("Domain.Models.RefreshToken", b =>
                {
                    b.HasOne("Domain.Models.AppUser", "AppUser")
                        .WithMany("refreshTokens")
                        .HasForeignKey("AppUserId")
                        .OnDelete(DeleteBehavior.Restrict)
                        .IsRequired();

                    b.Navigation("AppUser");
                });

            modelBuilder.Entity("Domain.Models.Transaction", b =>
                {
                    b.HasOne("Domain.Models.Client", "Client")
                        .WithMany("Transactions")
                        .HasForeignKey("ClientId")
                        .OnDelete(DeleteBehavior.Restrict)
                        .IsRequired();

                    b.Navigation("Client");
                });

            modelBuilder.Entity("Domain.Models.Account", b =>
                {
                    b.Navigation("Cards");
                });

            modelBuilder.Entity("Domain.Models.AppUser", b =>
                {
                    b.Navigation("refreshTokens");
                });

            modelBuilder.Entity("Domain.Models.Card", b =>
                {
                    b.Navigation("Pan")
                        .IsRequired();
                });

            modelBuilder.Entity("Domain.Models.Client", b =>
                {
                    b.Navigation("Accounts");

                    b.Navigation("AppUsers");

                    b.Navigation("Transactions");
                });
#pragma warning restore 612, 618
        }
    }
}

// <auto-generated />
using System;
using Infrastructure.DbContext;
using Microsoft.EntityFrameworkCore;
using Microsoft.EntityFrameworkCore.Infrastructure;
using Microsoft.EntityFrameworkCore.Storage.ValueConversion;
using Npgsql.EntityFrameworkCore.PostgreSQL.Metadata;

#nullable disable

namespace Infrastructure.Migrations
{
    [DbContext(typeof(AppDbContext))]
    partial class AppDbContextModelSnapshot : ModelSnapshot
    {
        protected override void BuildModel(ModelBuilder modelBuilder)
        {
#pragma warning disable 612, 618
            modelBuilder
                .HasAnnotation("ProductVersion", "9.0.9")
                .HasAnnotation("Relational:MaxIdentifierLength", 63);

            NpgsqlModelBuilderExtensions.UseIdentityByDefaultColumns(modelBuilder);

            modelBuilder.Entity("Domain.Models.Account", b =>
                {
                    b.Property<Guid>("Id")
                        .ValueGeneratedOnAdd()
                        .HasColumnType("uuid");

                    b.Property<decimal>("Balance")
                        .HasColumnType("numeric");

                    b.Property<Guid>("ClientId")
                        .HasColumnType("uuid");

                    b.Property<decimal?>("DepositedLastDay")
                        .HasColumnType("numeric");

                    b.Property<string>("Iban")
                        .IsRequired()
                        .HasColumnType("text");

                    b.Property<DateOnly>("LastDepositDateKz")
                        .HasColumnType("date");

                    b.Property<DateOnly>("LastTransferDateKz")
                        .HasColumnType("date");

                    b.Property<decimal?>("TransferredLastDay")
                        .HasColumnType("numeric");

                    b.HasKey("Id");

                    b.HasIndex("ClientId");

                    b.ToTable("Accounts");
                });

            modelBuilder.Entity("Domain.Models.AppUser", b =>
                {
                    b.Property<Guid>("Id")
                        .ValueGeneratedOnAdd()
                        .HasColumnType("uuid");

                    b.Property<DateTime?>("BlockedUntil")
                        .HasColumnType("timestamp with time zone");

                    b.Property<DateTime?>("BlockedUntilPassword")
                        .HasColumnType("timestamp with time zone");

                    b.Property<Guid>("ClientId")
                        .HasColumnType("uuid");

                    b.Property<int>("CountOfLoginAttempts")
                        .HasColumnType("integer");

                    b.Property<int>("CountOfLoginViaPasswordAttempts")
                        .HasColumnType("integer");

                    b.Property<string>("Email")
                        .IsRequired()
                        .HasColumnType("text");

                    b.Property<string>("HashedPinCode")
                        .IsRequired()
                        .HasColumnType("text");

                    b.Property<bool>("IsActive")
                        .HasColumnType("boolean");

                    b.Property<string>("PasswordHash")
                        .IsRequired()
                        .HasColumnType("text");

                    b.Property<int>("VerificationStatus")
                        .HasColumnType("integer");

                    b.HasKey("Id");

                    b.HasIndex("ClientId");

                    b.ToTable("AppUsers");
                });

            modelBuilder.Entity("Domain.Models.Card", b =>
                {
                    b.Property<Guid>("Id")
                        .ValueGeneratedOnAdd()
                        .HasColumnType("uuid");

                    b.Property<Guid>("AccountId")
                        .HasColumnType("uuid");

                    b.Property<int>("CountOfPinAttempts")
                        .HasColumnType("integer");

                    b.Property<string>("ExpiryDate")
                        .HasColumnType("text");

                    b.Property<string>("PanMasked")
                        .HasColumnType("text");

                    b.Property<string>("PinCode")
                        .HasColumnType("text");

                    b.Property<int?>("Status")
                        .HasColumnType("integer");

                    b.HasKey("Id");

                    b.HasIndex("AccountId");

                    b.ToTable("Cards");
                });

            modelBuilder.Entity("Domain.Models.Client", b =>
                {
                    b.Property<Guid>("Id")
                        .ValueGeneratedOnAdd()
                        .HasColumnType("uuid");

                    b.Property<string>("FullName")
                        .HasColumnType("text");

                    b.Property<string>("IIN")
                        .IsRequired()
                        .HasColumnType("text");

                    b.Property<bool>("IsDeleted")
                        .HasColumnType("boolean");

                    b.Property<int>("KycStatus")
                        .HasColumnType("integer");

                    b.Property<string>("PhoneNumber")
                        .HasColumnType("text");

                    b.HasKey("Id");

                    b.ToTable("Clients");
                });

            modelBuilder.Entity("Domain.Models.Pan", b =>
                {
                    b.Property<Guid>("Id")
                        .ValueGeneratedOnAdd()
                        .HasColumnType("uuid");

                    b.Property<Guid>("CardId")
                        .HasColumnType("uuid");

                    b.Property<byte[]>("CipherText")
                        .IsRequired()
                        .HasColumnType("bytea");

                    b.Property<byte[]>("Nonce")
                        .IsRequired()
                        .HasColumnType("bytea");

                    b.Property<byte[]>("Tag")
                        .IsRequired()
                        .HasColumnType("bytea");

                    b.HasKey("Id");

                    b.HasIndex("CardId")
                        .IsUnique();

                    b.ToTable("Pans");
                });

            modelBuilder.Entity("Domain.Models.RefreshToken", b =>
                {
                    b.Property<Guid>("Id")
                        .ValueGeneratedOnAdd()
                        .HasColumnType("uuid");

                    b.Property<Guid>("AppUserId")
                        .HasColumnType("uuid");

                    b.Property<string>("DeviceInfo")
                        .HasColumnType("text");

                    b.Property<DateTime>("Expires")
                        .HasColumnType("timestamp with time zone");

                    b.Property<DateTime>("RevokedAt")
                        .HasColumnType("timestamp with time zone");

                    b.Property<string>("Token")
                        .IsRequired()
                        .HasColumnType("text");

                    b.Property<Guid>("UserId")
                        .HasColumnType("uuid");

                    b.HasKey("Id");

                    b.HasIndex("AppUserId");

                    b.ToTable("RefreshTokens");
                });

            modelBuilder.Entity("Domain.Models.Transaction", b =>
                {
                    b.Property<Guid>("Id")
                        .ValueGeneratedOnAdd()
                        .HasColumnType("uuid");

                    b.Property<decimal>("Amount")
                        .HasColumnType("numeric");

                    b.Property<Guid>("ClientId")
                        .HasColumnType("uuid");

                    b.Property<DateTime>("CreatedAt")
                        .HasColumnType("timestamp with time zone");

                    b.Property<string>("From")
                        .IsRequired()
                        .HasColumnType("text");

                    b.Property<string>("To")
                        .IsRequired()
                        .HasColumnType("text");

                    b.Property<string>("Type")
                        .IsRequired()
                        .HasColumnType("text");

                    b.HasKey("Id");

                    b.HasIndex("ClientId");

                    b.ToTable("Transactions");
                });

            modelBuilder.Entity("Domain.Models.Account", b =>
                {
                    b.HasOne("Domain.Models.Client", "Client")
                        .WithMany("Accounts")
                        .HasForeignKey("ClientId")
                        .OnDelete(DeleteBehavior.Restrict)
                        .IsRequired();

                    b.Navigation("Client");
                });

            modelBuilder.Entity("Domain.Models.AppUser", b =>
                {
                    b.HasOne("Domain.Models.Client", "Client")
                        .WithMany("AppUsers")
                        .HasForeignKey("ClientId")
                        .OnDelete(DeleteBehavior.Restrict)
                        .IsRequired();

                    b.Navigation("Client");
                });

            modelBuilder.Entity("Domain.Models.Card", b =>
                {
                    b.HasOne("Domain.Models.Account", "Account")
                        .WithMany("Cards")
                        .HasForeignKey("AccountId")
                        .OnDelete(DeleteBehavior.Cascade)
                        .IsRequired();

                    b.Navigation("Account");
                });

            modelBuilder.Entity("Domain.Models.Pan", b =>
                {
                    b.HasOne("Domain.Models.Card", "Card")
                        .WithOne("Pan")
                        .HasForeignKey("Domain.Models.Pan", "CardId")
                        .OnDelete(DeleteBehavior.Cascade)
                        .IsRequired();

                    b.Navigation("Card");
                });

            modelBuilder.Entity("Domain.Models.RefreshToken", b =>
                {
                    b.HasOne("Domain.Models.AppUser", "AppUser")
                        .WithMany("refreshTokens")
                        .HasForeignKey("AppUserId")
                        .OnDelete(DeleteBehavior.Restrict)
                        .IsRequired();

                    b.Navigation("AppUser");
                });

            modelBuilder.Entity("Domain.Models.Transaction", b =>
                {
                    b.HasOne("Domain.Models.Client", "Client")
                        .WithMany("Transactions")
                        .HasForeignKey("ClientId")
                        .OnDelete(DeleteBehavior.Restrict)
                        .IsRequired();

                    b.Navigation("Client");
                });

            modelBuilder.Entity("Domain.Models.Account", b =>
                {
                    b.Navigation("Cards");
                });

            modelBuilder.Entity("Domain.Models.AppUser", b =>
                {
                    b.Navigation("refreshTokens");
                });

            modelBuilder.Entity("Domain.Models.Card", b =>
                {
                    b.Navigation("Pan")
                        .IsRequired();
                });

            modelBuilder.Entity("Domain.Models.Client", b =>
                {
                    b.Navigation("Accounts");

                    b.Navigation("AppUsers");

                    b.Navigation("Transactions");
                });
#pragma warning restore 612, 618
        }
    }
}

// <autogenerated />
using System;
using System.Reflection;
[assembly: global::System.Runtime.Versioning.TargetFrameworkAttribute(".NETCoreApp,Version=v9.0", FrameworkDisplayName = ".NET 9.0")]

//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Runtime Version:4.0.30319.42000
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

using System;
using System.Reflection;

[assembly: System.Reflection.AssemblyCompanyAttribute("Infrastructure")]
[assembly: System.Reflection.AssemblyConfigurationAttribute("Debug")]
[assembly: System.Reflection.AssemblyFileVersionAttribute("1.0.0.0")]
[assembly: System.Reflection.AssemblyInformationalVersionAttribute("1.0.0+89d32106120063aadf12636df3d6a97522ccdea6")]
[assembly: System.Reflection.AssemblyProductAttribute("Infrastructure")]
[assembly: System.Reflection.AssemblyTitleAttribute("Infrastructure")]
[assembly: System.Reflection.AssemblyVersionAttribute("1.0.0.0")]

// Generated by the MSBuild WriteCodeFragment class.


// <auto-generated/>
global using global::System;
global using global::System.Collections.Generic;
global using global::System.IO;
global using global::System.Linq;
global using global::System.Net.Http;
global using global::System.Threading;
global using global::System.Threading.Tasks;


using System.Security.Cryptography;
using System.Text;
using Application.Interfaces;
using Microsoft.Extensions.Configuration;

namespace Infrastructure.PanServices
{
    public class PanEncryptor : IPanEncryptor
    {
        private readonly byte[] _key;
        public PanEncryptor(byte[] key)
        {
            _key = key;
        }
        public (byte[] CipherText, byte[] Nonce, byte[] Tag) Encrypt(string pan)
        {
            byte[] nonce = RandomNumberGenerator.GetBytes(12);
            byte[] plainText = Encoding.UTF8.GetBytes(pan);
            byte[] cipherText = new byte[plainText.Length];
            byte[] tag = new byte[16];

            using var aes = new AesGcm(_key, 16);
            aes.Encrypt(nonce, plainText, cipherText, tag);

            return (cipherText, nonce, tag);
        }
        public string Decrypt(byte[] CipherText, byte[] Nonce, byte[] Tag)
        {
            var plaintext = new byte[CipherText.Length];
            using var aes = new AesGcm (_key, 16);
            aes.Decrypt(Nonce, CipherText, Tag, plaintext);
            return Encoding.UTF8.GetString(plaintext);
        }
    }
}

using System.Security.Cryptography;
using System.Text;
using Application.Interfaces.Services;
using Domain.Enums;
using Domain.Models;
namespace Infrastructure.PanServices
{
    public class Pan_generation : IPanService
    {
        public string CreatePan(Client client)
        {
            const string MII = "6";
            const string issuerBin = "10182";

            const string BIN = MII + issuerBin;

            byte[] bytes = Encoding.UTF8.GetBytes(client.Id.ToString());

            using SHA256 sha256 = SHA256.Create();

            bytes = sha256.ComputeHash(bytes);

            uint value = BitConverter.ToUInt32(bytes, 0);

            string unique_number = value.ToString("D6");

            string card_type = ((int)CardType.Debit).ToString();

            string card_number = string.Concat(card_type, unique_number);

            string control_number = ControlNumber(BIN, card_number);

            string pan = string.Concat(BIN, card_number, control_number);

            return pan;
        }
        public string ControlNumber(string BIN, string card_number)
        {
            string pan_part = BIN + card_number;
            bool double_digit = true;
            int sum = 0;
            for (int i = pan_part.Length - 1; i > 1; i--)
            {
                int digit = int.Parse(pan_part[i].ToString());
                if (double_digit)
                {
                    digit *= 2;
                    if (digit > 9)
                    {
                        digit -= 9;
                    }
                }
                sum += digit;
                double_digit = !double_digit;
            }
            return ((10 - sum % 10) % 10).ToString();
        }
    }
}

using Application.DTO.CardDTO;
using Application.Interfaces.Repositories;
using Domain.Models;
using Infrastructure.DbContext;
using Microsoft.EntityFrameworkCore;

namespace Infrastructure.Repositories
{
    public class AccountRepository : IAccountRepository
    {
        private readonly AppDbContext _context;

        public AccountRepository(AppDbContext context)
        {
            _context = context;
        }
        public async Task AddEncyptedPan(Pan pan)
        {
            await _context.Pans.AddAsync(pan);
        }
        public async Task AddCard(Card card)
        {
            await _context.Cards.AddAsync(card);
        }
        public async Task AddAccount(Account account)
        {
            await _context.Accounts.AddAsync(account);
        }
        public async Task<IEnumerable<GetCardDTO>> GetAllCards(Guid clientId)
        {
            var list = await _context.Accounts
            .AsNoTracking()
            .Where(a => a.ClientId == clientId)
            .SelectMany(a => a.Cards.Select(card => new GetCardDTO
            {
                PanMasked = card.PanMasked,
                Balance = a.Balance,
                Status = card.Status.ToString(),
            }))
            .ToListAsync();
            return list;
        }
        public async Task<Account> GetAccountById(Guid accountId)
        {
            var account = await _context.Accounts.FindAsync(accountId);
            return account ?? throw new ArgumentNullException();
        }
        public async Task<Card> GetRequisitesDTOAsync(Guid clientId, string last_numbers)
        {
            var result = await _context.Clients
                .AsNoTracking()
                .Include(ac => ac.Accounts)
                    .ThenInclude(ca => ca.Cards)
                        .ThenInclude(ka => ka.Pan)
                .Where(cl => cl.Id == clientId)
                .SelectMany(a => a.Accounts)
                .SelectMany(c => c.Cards)
                .FirstOrDefaultAsync(cr => cr.PanMasked!.EndsWith(last_numbers));

            return result ?? throw new Exception("Card is null");
        }
        public async Task<Account> GetAccountByIban(string iban)
        {
            var account = await _context.Accounts.Include(c => c.Client).FirstOrDefaultAsync(a => a.Iban == iban);
            return account ?? throw new ArgumentNullException();
        }
    }
}

using Application.Interfaces.Repositories;
using Domain.Models;
using Infrastructure.DbContext;
using Microsoft.EntityFrameworkCore;

namespace Infrastructure.Repositories
{
    public class AppUserRepository : IAppUserRepository
    {
        private readonly AppDbContext _context;

        public AppUserRepository(AppDbContext context)
        {
            _context = context;
        }
        public async Task SaveDataAppUserAsync(AppUser appUser)
        {
            await _context.AppUsers.AddAsync(appUser);
        }
        public async Task<AppUser> GetAppUserAsync(Guid Id)
        {
            var result = await _context.AppUsers.AsNoTracking()
                .Include(u => u.Client)
                    .ThenInclude(a => a.Accounts)
                .FirstOrDefaultAsync(appUser => appUser.Id == Id);
            return result!;
        }
        public async Task<bool> ExistsByEmailAsync(string email)
        {
            bool exists = await _context.AppUsers.AnyAsync(user => user.Email == email);
            return exists;
        }
        public async Task<AppUser?> GetAppUserByEmail(string email)
        {
            AppUser? appUser = await _context.AppUsers.FirstOrDefaultAsync(user => user.Email == email);
            return appUser;
        }
    }
}

using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using Application.Interfaces.Repositories;
using Domain.Models;
using Infrastructure.DbContext;
using Microsoft.EntityFrameworkCore;

namespace Infrastructure.Repositories
{
    public class AuthRepository : IAuthRepository
    {
        private readonly AppDbContext _context;

        public AuthRepository(AppDbContext context)
        {
            _context = context;
        }
        public async Task SaveRefreshToken(RefreshToken refreshToken)
        {
            await _context.RefreshTokens.AddAsync(refreshToken);
        }
        public async Task<RefreshToken?> FindRefreshToken(string refreshToken)
        {
            var result = await _context.RefreshTokens.AsNoTracking().Include(rt => rt.AppUser).FirstOrDefaultAsync(token => token.Token == refreshToken);
            return result;
        }
    }
}

using Application.Interfaces.Repositories;
using Domain.Models;
using Infrastructure.DbContext;
using Microsoft.EntityFrameworkCore;

namespace Infrastructure.Repositories
{
    public class ClientRepository : IClientRepository
    {
        private readonly AppDbContext _context;

        public ClientRepository(AppDbContext context)
        {
            _context = context;
        }
        public async Task<bool> ExistsByIINAsync(string iin)
        {
            bool exists = await _context.Clients.AnyAsync(client => client.IIN == iin);
            return exists;
        }
        public async Task<Client?> FindByIINAsync(string iin)
        {
            Client? client = await _context.Clients.FirstOrDefaultAsync(client => client.IIN == iin);
            return client;
        }
        public async Task SaveDataClientAsync(Client client)
        {
            await _context.Clients.AddAsync(client);
        }
        public async Task<int> DeleteAsync(string IIN)
        {
            int affected = await _context.Clients
            .Where(c => c.IIN == IIN)
            .ExecuteDeleteAsync();

            return affected;
        }
    }
}

using Application.Interfaces.Repositories;
using Microsoft.EntityFrameworkCore.Storage;
using Domain.Models;
using Infrastructure.DbContext;

namespace Infrastructure.Repositories
{
        public class TransactionRepository : ITransactionRepository
    {
            private readonly AppDbContext _dbContext;

            public TransactionRepository(AppDbContext dbContext)
            {
                _dbContext = dbContext;
            }

            public async Task<IDbContextTransaction> BeginTransactionAsync()
            {
                return await _dbContext.Database.BeginTransactionAsync();
            }
            public async Task AddTransaction(Transaction transaction)
            {
                await _dbContext.Transactions.AddAsync(transaction);
            }

        }
}

using System.Reflection.Metadata.Ecma335;
using System.Runtime.InteropServices;
using Application.Interfaces.Repositories;
using Domain.Models;
using Infrastructure;
using Infrastructure.DbContext;
using Microsoft.EntityFrameworkCore;
namespace Infrastructure.Repositories
{
    public class UserRepository : IUserRepository
    {
        private readonly AppDbContext _context;

        public UserRepository(AppDbContext context)
        {
            _context = context;
        }
        public async Task SaveChangesAsync()
        {
            try
            {
                await _context.SaveChangesAsync();
            }
            catch (DbUpdateException ex)
            {
                throw new InvalidOperationException("Unsuccessful attempt to save data", ex);
            }
        }
        public async Task<string?> GetOrderNumber()
        {
            var number = await _context.Accounts.CountAsync();
            return number.ToString("D6");
        }
    }
}

using Application.Interfaces.Auth;
namespace Infrastructure
{
    public class Hasher : IHasher
    {
        public string Generate(string input) =>
            BCrypt.Net.BCrypt.EnhancedHashPassword(input);
        public bool Verify(string input, string hashedInput) =>
            BCrypt.Net.BCrypt.EnhancedVerify(input, hashedInput);
    }
}

using Serilog;
namespace Infrastructure
{
    public static class LoggingConfiguration 
    {
        public static ILogger CreateLogger(string logFilePath)
        {
            return new LoggerConfiguration()
                .MinimumLevel.Information() 
                .WriteTo.Console()
                .WriteTo.File(logFilePath, rollingInterval: RollingInterval.Day)
                .Enrich.WithThreadId()
                .Enrich.WithProcessId()
                .Enrich.WithMachineName()
                .CreateLogger();
        }
    }
}

